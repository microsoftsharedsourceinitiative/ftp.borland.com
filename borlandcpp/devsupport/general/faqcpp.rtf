{\rtf1\ansi \deff5\deflang1033{\fonttbl{\f0\froman\fcharset0\fprq2 Tms Rmn;}{\f1\froman\fcharset2\fprq2 Symbol;}{\f2\fswiss\fcharset0\fprq2 Helv;}{\f3\fmodern\fcharset0\fprq1 Courier;}
{\f4\froman\fcharset0\fprq2 Times New Roman;}{\f5\fswiss\fcharset0\fprq2 Arial;}{\f6\froman\fcharset0\fprq2 MS Serif;}{\f7\fswiss\fcharset0\fprq2 MS Sans Serif;}{\f8\froman\fcharset0\fprq2 Times;}{\f9\fswiss\fcharset0\fprq2 Helvetica;}
{\f10\fswiss\fcharset0\fprq2 System;}{\f11\fmodern\fcharset0\fprq1 Courier New;}{\f12\fmodern\fcharset0\fprq1 LinePrinter;}{\f13\froman\fcharset0\fprq2 CG Times;}{\f14\froman\fcharset0\fprq2 CG Times Bold;}{\f15\froman\fcharset0\fprq2 CG Times Italic;}
{\f16\fswiss\fcharset0\fprq2 Univers;}{\f17\fswiss\fcharset0\fprq2 Univers Condensed;}{\f18\fswiss\fcharset0\fprq2 Antique Olive;}{\f19\froman\fcharset0\fprq2 Garamond;}{\f20\fswiss\fcharset0\fprq2 CG Omega;}
{\f21\froman\fcharset0\fprq2 Clarendon Condensed;}{\f22\fmodern\fcharset0\fprq1 Lucida Console;}{\f23\fnil\fcharset2\fprq2 Wingdings;}{\f24\froman\fcharset2\fprq2 MT Extra;}{\f25\fmodern\fcharset2\fprq1 MS LineDraw;}{\f26\fdecor\fcharset0\fprq2 Algerian;}
{\f27\fswiss\fcharset0\fprq2 Arial Rounded MT Bold;}{\f28\froman\fcharset0\fprq2 Bookman Old Style;}{\f29\fdecor\fcharset0\fprq2 Braggadocio;}{\f30\fswiss\fcharset0\fprq2 Britannic Bold;}{\f31\fscript\fcharset0\fprq2 Brush Script MT;}
{\f32\fswiss\fcharset0\fprq2 Century Gothic;}{\f33\fdecor\fcharset0\fprq2 Colonna MT;}{\f34\fdecor\fcharset0\fprq2 Desdemona;}{\f35\froman\fcharset0\fprq2 Footlight MT Light;}{\f36\fswiss\fcharset0\fprq2 Impact;}{\f37\fdecor\fcharset0\fprq2 Kino MT;}
{\f38\froman\fcharset0\fprq2 Wide Latin;}{\f39\fscript\fcharset0\fprq2 Matura MT Script Capitals;}{\f40\fdecor\fcharset0\fprq2 Playbill;}{\f41\fswiss\fcharset0\fprq2 Arial Super;}{\f42\froman\fcharset0\fprq2 Pars Ziba - Draft;}
{\f43\froman\fcharset0\fprq2 Garamond EC;}{\f44\fnil\fcharset0\fprq2 SaintFrancis;}{\f45\fnil\fcharset0\fprq2 Black Chancery;}{\f46\fnil\fcharset2\fprq2 MS Reference 1;}{\f47\fnil\fcharset2\fprq2 MS Reference 2;}
{\f48\fswiss\fcharset0\fprq2 Bookshelf Symbol 1;}{\f49\fswiss\fcharset0\fprq2 Bookshelf Symbol 2;}{\f50\froman\fcharset2\fprq2 Bookshelf Symbol 3;}{\f51\fmodern\fcharset0\fprq2 OCR-A;}{\f52\fmodern\fcharset0\fprq2 QuickType Mono;}
{\f53\fswiss\fcharset0\fprq2 QuickType;}{\f54\fswiss\fcharset0\fprq2 QuickType Condensed;}{\f55\fnil\fcharset0\fprq2 QuickType Pi;}{\f56\froman\fcharset255\fprq2 Roman;}{\f57\fscript\fcharset255\fprq2 Script;}{\f58\fmodern\fcharset255\fprq2 Modern;}
{\f59\fswiss\fcharset0\fprq1 MS Dialog;}{\f60\froman\fcharset0\fprq0 Book Antiqua;}{\f61\fnil\fcharset0\fprq0 Monotype Sorts;}{\f62\froman\fcharset0\fprq0 CG Times (WN);}{\f63\fswiss\fcharset0\fprq0 Univers (WN);}{\f64\fnil\fcharset0\fprq0 Small Fonts;}}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;
\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 \snext0 Normal;}{\s1\li144\ri144\sb240\sa60\sl240\slmult0 \b\f9\ul 
\sbasedon0\snext0 heading 1;}{\s2\li144\ri144\sb120\sa60\sl240\slmult0 \b\f5\fs20 \sbasedon0\snext0 heading 2;}{\s3\li360\ri144\sb40\sa60\sl240\slmult0 \b\f5 \sbasedon0\snext18 heading 3;}{\*\cs10 \additive Default Paragraph Font;}{
\s15\li144\ri144\sb40\sa60\sl240\slmult0\tqc\tx4320\tqr\tx8640 \f5\fs20 \sbasedon0\snext15 footer;}{\s16\li144\ri144\sb40\sa60\sl240\slmult0\tqc\tx4320\tqr\tx8640 \f5\fs20 \sbasedon0\snext16 header;}{\s17\li144\ri144\sl240\slmult0 \f5\fs20 
\sbasedon0\snext17 footnote text;}{\s18\li576\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 \sbasedon0\snext18 Normal Indent;}{\s19\fi-216\li360\ri144\sl240\slmult0\tx360 \f11\fs20 \sbasedon0\snext19 Code;}{\s20\li360\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 
\sbasedon0\snext20 In1;}{\s21\fi-216\li360\ri144\sb140\sl240\slmult0 \b\f5\fs20 \sbasedon0\snext0 H2;}{\s22\li360\ri144\sb140\sl240\slmult0 \b\f5\fs20 \sbasedon0\snext20 H3;}{\s23\fi-187\li360\ri144\sa60\sl240\slmult0\tx360 \f5\fs20 \sbasedon0\snext23 
LS1;}{\s24\fi-180\li540\ri144\sa60\sl240\slmult0\tx540 \f5\fs20 \sbasedon23\snext24 LS2;}{\s25\fi-2563\li2707\ri144\sb40\sa60\sl240\slmult0\tx2700 \f5\fs20 \sbasedon0\snext25 T2;}{\s26\li43\ri144\sb40\sl-43\slmult0\keep\brdrt\brdrs\brdrw15\brsp20 \brdrbtw
\brdrs\brdrw15\brsp20 \f5\fs20 \sbasedon0\snext27 TLine;}{\s27\fi-4003\li4147\ri144\sb40\sa60\sl240\slmult0\tx2340\tx4140 \f5\fs20 \sbasedon0\snext27 T3;}{\s28\fi-4363\li4507\ri144\sb40\sa60\sl240\slmult0\tx1620\tx3060\tx4500 \f5\fs20 \sbasedon0\snext28 
T4;}{\s29\li144\ri144\sa104\sl240\slmult0 \b\f5\cf2 \sbasedon0\snext0 H1;}{\s30\fi-216\li360\ri144\sa60\sl240\slmult0\tx360 \f5\fs20 \sbasedon23\snext30 NUM1;}{\s31\fi-216\li576\ri144\sa60\sl240\slmult0\tx576 \f5\fs20 \sbasedon30\snext31 NUM2;}{
\s32\li144\sl240\slmult0\keep\tx360\tx547\tx720\tx907\tx1080\tx1267 \f11\fs20 \sbasedon19\snext32 CodeNW;}{\s33\li360\sl240\slmult0\keep\tx540\tx720\tx907\tx1080\tx1267\tx1440 \f11\fs20 \sbasedon32\snext33 CodeNWIn;}{
\s34\fi-216\li360\sb40\sa60\sl240\slmult0\keep\tx360\tx547\tx720\tx907\tx1080\tx1267 \f5\fs20 \sbasedon0\snext21 Syntax;}{\s35\fi-216\li360\ri144\sb120\sl240\slmult0\tx2347\tx4147 \b\f5\fs20 \sbasedon21\snext26 THead;}{
\s36\fi-576\li720\ri144\sb40\sa60\sl240\slmult0\tx720\tx8820 \f5\fs20 \sbasedon0\snext0 Note;}{\s37\sb40\sa60\sl240\slmult0 \f5\fs20 \sbasedon0\snext37 TCell;}{\s38\li144\ri144\sl240\slmult0\keepn\tx1170\tx2160\tx3150\tx4140 \f5\fs16 \sbasedon0\snext0 
H1Link;}{\s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 \sbasedon29\snext38 H1ns;}{\s40\fi-1296\li1440\ri144\sa60\sl240\slmult0\tx1440 \f5\fs20 \sbasedon0\snext40 ShortCut;}{\s41\li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 \sbasedon0\snext41 
Blurb;}{\s42\li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 \sbasedon0\snext42 NormalPrintOnly;}{\s43 \f5 \snext43 Base;}{\s44 \f5\fs36 \snext44 Banner Base;}{\s45 \f8\fs20 \sbasedon0\snext45 endnote text;}{\*\cs46 \additive\super \sbasedon10 
footnote reference;}{\*\cs47 \additive\super \sbasedon10 endnote reference;}}{\info{\author Steven Radecki}{\operator Steven Radecki}{\creatim\yr1995\mo1\dy23\hr13\min27}{\revtim\yr1995\mo1\dy23\hr14\min6}{\version1}{\edmins24}{\nofpages130}
{\nofwords16318}{\nofchars93013}{\vern49203}}\ftnbj\aendnotes\ftnnrlc\aftnnar\hyphcaps0 \fet2\sectd \linex0 {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3
\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}
{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain 
\s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} Nomenclature_and_common_abbreviations}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super $}
 Nomenclature and common abbreviations}}Nomenclature and common abbreviations
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Here are a few of the abbreviations/etc used in this article:
\par \pard\plain \s25\fi-2563\li2707\ri144\sb40\sa60\sl240\slmult0\tx2700 \f5\fs20 {\b Term\tab Meaning
\par }\pard\plain \s26\li43\ri144\sb40\sl-43\slmult0\keep\brdrt\brdrs\brdrw15\brsp20 \brdrbtw\brdrs\brdrw15\brsp20 \f5\fs20 
\par \pard\plain \s25\fi-2563\li2707\ri144\sb40\sa60\sl240\slmult0\tx2700 \f5\fs20 ctor\tab constructor
\par copy-ctor\tab copy constructor (also "X(const X&)", pronounced "X-X-ref")
\par dtor\tab destructor
\par fn\tab function
\par fns\tab functions
\par ptr\tab pointer, a C/C++ construct declared by:{\f11  int * p;}
\par ref\tab reference, a C++ construct declared by: {\f11 int & r;}
\par const\tab a C++ keyword which is short for "constant"
\par OO\tab object-oriented
\par OOP\tab object-oriented programming
\par OOPL\tab object-oriented programming language
\par method\tab an alternate term for "member function"
\par message\tab an alternate term for "invoking a member function"
\par nil\tab the "zero" or "empty" pointer ("NULL" in C, "0" in C++){\f10\fs24 
\par }\pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_books_are_available_for_C___}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super $}
 What books are available for C++?}}What books are available for C++?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Lots, with more just about every other week.  Here are a few in no particular order (comments are my own):
\par "The C++ Programming Language, second edition", Stroustrup, Addison/Wesley
\par \tab A rich, in-depth intro text; covers rudiments of OOD as well as OOP
\par \tab ISBN 0-201-12078-X
\par "A C++ Primer, 2nd edition", Lippman, Addison/Wesley
\par \tab 1st ed. considered std intro-C++ text; does not assume C; has some OOD
\par \tab ISBN 0-201-54848-8
\par "Annotated C++ Reference Manual", Ellis and Stroustrup, Addison/Wesley
\par \tab Heavy reading; definitely not for beginners; gives *ALL* the details.
\par \tab ISBN 0-201-51459-1
\par "Advanced C++ Programming Styles and Idioms", Coplien, Addison-Wesley, 1992
\par \tab ref-counting, wrappers, functionoids, "Self"/"Smalltalk" styles, etc
\par \tab ISBN 0-201-54855-0
\par "A C++ Toolkit", Shapiro, Prentice Hall
\par \tab Provides many small stand-alone classes; code is publically usable
\par \tab ISBN 0-13-127663-8
\par "Mastering C++", Horstmann, Wiley
\par \tab Wiley hasn't sent me one to review yet, but I hear it's great
\par "Teach Yourself C++", Stevens, MIS Press
\par \tab An easy-to-read short book for C++ beginners
\par \tab ISBN 1-558-28027-8
\par "A C++ Primer, first edition", Lippman, Addison/Wesley
\par \tab Slightly out-of-date; solidly reference quality wrt the language proper
\par \tab ISBN 0-201-16487-6
\par "Programming in C++", Dewhurst and Stark, Prentice Hall
\par \tab How-to-use C++, shows many idioms of the language
\par "Using C++", Eckel, McGraw-Hill
\par \tab Shows some of the ways C++ can be used as a better C; MS-DOS
\par "Data Abstraction and OO Programming in C++", Gorlen/Orlow/Plexico, Wiley
\par \tab Describes how to use NIHCL (see question on "NIHCL")
\par \tab ISBN 0-471-92346-X
\par "An Intro to OO Programming", Tim Budd, Addison-Wesley, 1991
\par \tab Covers OOP in general; compares/contrasts several OOPLs including C++
\par \tab ISBN 0-201-54709-0
\par "Object-Oriented Design with Applications", Grady Booch, Benjamin/Cummings,1991
\par \tab Excellent 1st book on OO design; read on Classification and Abstraction
\par \tab ISBN 0-8053-0091-0
\par "Object-Orientation: Concepts, Languages, Databases, User interfaces",
\par \tab Khoshafian and Abnous, J.Wiley, 1990
\par \tab ISBN 0-471-51801-8
\par "The Waite Group's C++ Programming", Berry
\par "An Introduction to Object-Oriented Programming and C++", Weiner & Pinson, A/W
\par "Object-Oriented Program Design with Examples in C++", Mullin, Addison-Wesley
\par "Hands-on C++ Programming", Isaac and Miller, Addison-Wesley
\par "C++ for C Programmers", Pohl, Benjamin/Cummings
\par "The C++ Programming Language, first edition", Stroustrup, Addison/Wesley
\par \tab Out of date but a classic; get it to find out where the language "was"
\par \tab ISBN 0-201-12078-X
\par "The C++ Answer Book", Hansen, Addison/Wesley
\par \tab Answers to the exercises in Stroustrup's first ed; solid "how-to" text
\par \tab ISBN 0-201-11497-6
\par "Turbo C++ DiskTutor", Greg Voss and Paul Chui, McGraw-Hill
\par \tab ISBN 0-07-881526-6
\par "Object-Oriented Software Construction", Meyer, Prentice Hall
\par \tab Chaps 1-4 are about OOP in general; the rest is about Eiffel language
\par \tab ISBN 0-13-629049-3
\par Conference proceedings:
\par \tab Proceedings of the "OOPSLA" conferences
\par \tab Proceedings of the "C++ At Work" conferences
\par \tab Proceedings of the "USENIX C++" conferences
\par Periodicals:
\par \tab The C++ Report
\par \tab Journal of Object-Oriented Programming
\par \tab Journal of C++
\par \tab the working papers of the ANSI-C++ committee
\par Usenix newsgroups and mailing lists:
\par \tab comp.lang.c++
\par \tab comp.std.c++
\par \tab comp.object
\par \tab BIX{\f10\fs24 
\par }\tab Turbo-C++ mailing list
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} Is_C___backward_compatible_with_ANSI_C_}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super $}
 Is C++ backward compatible with ANSI C?}}Is C++ backward compatible with ANSI C?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Almost. 
\par C++ is as close as possible to compatible with C but no closer. In practice, the major difference is that C++ requires prototypes, and that "f()" declares a function that takes no parameters, while ANSI-C rules state that "f()" declares a function that ta
kes any number of parameters of any type. There are some very subtle differences as well, like the sizeof a char literal being equal to the sizeof a char (in ANSI-C, 
sizeof('x') is the sizeof an int). Structure "tags" are in the same namespace as other names in C++, but C++ has some warts to take care of backward compatibility here.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} Where_can_I_ftp_a_copy_of_the_latest_ANSI_C___draft_standard_}${\footnote\ftnalt \pard\plain \s45 
\f8\fs20 {\cs47\super $} Where can I ftp a copy of the latest ANSI C++ draft standard?}}Where can I ftp a copy of the latest ANSI C++ draft standard?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 ANSI standards and/or drafts are NOT available in machine readable form.  There is NOT an "ftp" site that has a copy.  You can get a paper copy ($65) from:
\par 
\par      X3 Secretariat
\par      CBEMA
\par      1250 I Street NW
\par      Suite 200
\par      Washington, DC  20005
\par      202-626-5738
\par 
\par Ask for the latest version of "Working Paper for Draft Proposed American National Standard for Information Systems -- Programming Language C++."
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} Are_there_any_C___standardization_efforts_underway_}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {
\cs47\super $} Are there any C++ standardization efforts underway? }}Are there any C++ standardization efforts underway?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Yes; ANSI (American) and ISO (International) groups are working closely with each 
other.  The ANSI-C++ committee is called "X3J16".  The ISO C++ standards group is called "WG21".  The major players in the ANSI/ISO C++ standards process includes just about everyone:
\par AT&T, IBM, DEC, HP, Sun, MS, Borland, Zortech, Apple, OSF, etc ad nauseum. About 70 people attend each meeting.  People come from USA, UK, Japan, Germany, Sweden, Denmark, France, ... (all have "local" committees sending official representatives and condu
cting "local" meetings).{\f10\fs24 
\par }\pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} Who_uses_C___}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super $} Who uses C++? }}Who uses 
C++?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Lots and lots of companies and government sites.  Lots.
\par Statistically, 5 people became new C++ programmers while you read the words of the previous FAQ.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_are_some_advantages_of_C___}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super $}
 What are some advantages of C++? }}What are some advantages of C++?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 {\b\ul GROWTH OF C++:}
 C++ is by far the most popular OOPL.  The number of C++ users is doubling every 7.5 to 9 months.  Knowing C++ is a good resume-stuffer (but use it as an OOPL rather than just as a better C).
\par 
\par {\b\ul ENCAPSULATION:} Hiding our data structures a
llows us to change one chunk of a system without breaking other chunks.  We provide our software chunks (we call them "classes") with safe interfaces.  Users of a chunk use its interface only.The relatively volatile "implementation" of this interface is "
encapsulated" ("put into a capsule") to prevent users from becoming reliant on its temporary decisions.  In simple C, this was done by making a module's data "static", thus preventing another module from accessing our module's bits.
\par 
\par {\b\ul MULTIPLE INSTANCES:}
 The typical C solution to encapsulation (see above) doesn't support multiple instances of the data (it's hard to make multiple instances of a module's "static" data).  If we needed multiple instances in C, we used a "struct" (but this doesn't support "en
capsulation").  In C++, we can have both multiple instances and encapsulation via a "class": the "public" part
\par of a class contains the class's interface (normally these are a special kind of function called a "member function"), and the "private" part of a class contains the class's implementation (typically these are where the bits live).
\par 
\par {\b\ul INLINE FUNCTION CALLS:}
 In straight C, you can achieve "encapsulated structs" by putting a "void*" in a struct (the access functions use pointer casts).  This forfeits type safety, and also imposes a function call to access even trivial fields of the struct (if you allowed dire
ct access to
\par the struct's fields, the underlying data structure would be difficult to change since too many chunks would RELY on it being the "old" w
ay). Function call overhead is small, but can add up.  C++ classes allow function calls to be expanded "inline," so you have: 
\par 
\par \tab 1) safety of encapsulation
\par \tab 2) convenience of multiple instances
\par \tab 3) speed of direct access.  
\par 
\par Furthermore the parameter types of these inline functions are checked by the compiler, an improvement over C's #define macros.
\par 
\par {\b\ul OVERLOADING OPERATORS:} C++ lets you overload the standard operators on a class, which lets users exploit their intuition (e.g., "myString + yourString" might d
o string concatenation, "myDate++" might increment the date, "z1 * z2" might multiply complex numbers z1 and z2,
\par "a[i]" might access the "i"th element of the "linked list" called "a", etc.  You can even have "smart pointers" that could "point" to a disk record or wherever ("x = *p" could "dereference" such a pointer, which could seek to the location on disk where p 
"points" and return its value").  This
\par allows users to progrom in the language of the problem domain rather than in the language of the machine.
\par 
\par {\b\ul INHERITANCE:}
 We still have just scratched the surface.  In fact, we haven't even gotten to the "object-oriented" part yet!  Suppose you have a Stack data type with operations push, pop, etc.  Suppose you want an InvertableStack, which is "just like" Stack except it a
lso has an "invert"
\par operation.  In "C" style, you'd have to either (1) modify the existing Stack module (trouble if
\par "Stack" is being used by others), or (2) copy Stack into another file and text edit that file (results in lots of code duplicat
ion, another chance to break something tricky in the Stack part of invertableStack, and especially twice as much code to maintain).  C++ provides a much
\par cleaner solution: inheritance. You say "InvertableStack inherits everything from Stack, and
\par InvertableStack adds the invert operation."  Done.  Stack itself remains "closed" (untouched, unmodified), and InvertableStack doesn't duplicate the code for push/pop/etc.
\par 
\par {\b\ul POLYMORPHISM AND DYNAMIC BINDING:} The real power of OOP isn't just inheritance, but is the abi
lity to pass an InvertableStack around as if it actually were a Stack.  This is "safe" since (in C++ at least) the is-a relation follows public inheritance (i.e., a InvertableStack is-a Stack that can also invert itself). Polymorphism and dynamic binding 
are easiest to understand from an
\par example, so here's a "classic": a graphical draw package might deal with Circles, Squares,
\par Rectangles, general Polygons, and Lines.  All of these are Shapes.  Most of the draw package's functions need a "Shape" parameter (a
s opposed to some particular kind of shape like Square).  E.g., if a Shape is picked by a mouse, the Shape might get dragged across the screen and placed into a new location. Polymorphism and dynamic binding allow the code to work correctly
\par even if the compiler knows only that the parameter is a "Shape" without knowing the exact kind of Shape it is.  Furthermore suppose the "pick_and_drag(Shape*) function just mentioned was compiled on Tuesday, and on Wednesday you decide to add the Hexagon 
shape.  Strange 
as it sounds, pick_and_drag() will still work with Hexagons, even though the Hexagon didn't even exist when pick_and_drag() was compiled!!  (it's not really "amazing" once you understand how the C++ compiler does it -- but it's still very convenient!)

\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 \page {\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_is_C_____What_is_OOP_}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super $}
 What is C++?  What is OOP?}}What is C++?  What is OOP?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 OO programming techniques are the best way we know of to develop large, complex software applications and systems.
\par C++ is an OO programming language.  C++ can be used both as an OOPL and simply
\par "as a better C."  However if you use it "as a better C," don't expect to get the benefits of object-oriented programming.
\par OO hype: the software industry is "failing" to meet demands for large, complex software systems.  But this "failure" is actually due to our SUCCESSES: our successes have propelled users to ask for more. Unfortunately we created a market hunger that the "s
tructured" analysis,
\par design and programming techniques couldn't satisfy.  This required us to create a better paradigm.{\f10\fs24 
\par }\pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_is_a_class_}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super $} What is a class?}}
What is a class?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 
A class defines a data type, much like a struct would be in C.  In a CompScience sense, a type consists of two things: a set of values *and* a set of operations which operate on those values.  Thus "int' all by itself isn't a true "type' until you add ope
rations like "add two ints" or "int*int", etc.  In exactly the same way, a "class" provides a set of (usu
ally "public") operations, and a set of (usually non-public) data bits representing the abstract values that instances of the type can have.  From a C language perspective, a "class" is a "struct" whose members default to "private".
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_is_an_object_}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super $} What is an object?}}
What is an object?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 
An object is a region of storage with associated semantics.  After the declaration "int i;", we say that "i is an object of type int".  In C++/OOP, "object" is usually used to mean "an instance of a class".  Thus a 
classdefines the behavior of possibly many objects (instances).
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_is_a_reference_}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super $} What is a reference?}
}What is a reference?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 A reference is an alias (an alternate name) for an object.  It is frequently used for pass-by-reference; ex:
\par \tab {\f11 void swap(int& i, int& j)
\par \tab \{
\par \tab   int tmp = i;
\par \tab   i = j;
\par \tab   j = tmp;
\par \tab \}
\par \tab main()
\par \tab \{
\par \tab   int x, y;
\par \tab   //...
\par \tab   swap(x,y);
\par \tab \}}{\f10\fs24 
\par }Here "i" and "j" are aliases for main's "x" and "y" respectively.  The effect is as if you used the C style pass-by-pointer, but the "&" is moved from the caller into the callee.  Pascal enthusiasts will recognize this as a VAR param.{\f10\fs24 
\par }\pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_happens_if_you_assign_to_a_reference_}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super $
} What happens if you assign to a reference?}}What happens if you assign to a reference?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 
Assigning to a reference changes the referred-to value, thus a ref is an "Lvalue" (something that can appear on the "Left-hand-side of an assignment statement) for the referred-to value.  This insight can be pushed a bit farther by allowing refere
nces to be *returned*, thus allowing function calls on the left hand side of an assignment stmt.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} How_can_you_reseat_a_reference_to_make_it_refer_to_a_different_object_}${\footnote\ftnalt \pard\plain 
\s45 \f8\fs20 {\cs47\super $} How can you reseat a reference to make it refer to a different object?}}How can you reseat a reference to make it refer to a different object?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Unlike a pointer, once a reference is bound to an object, it can NOT be "reseated" to another object.  The reference itself isn't an object; you can't separate the reference from the referred-to-
object.  Ex: "&ref" is the address of the referred-to-object, not of the reference itself.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} When_should_I_use_references__and_when_should_I_use_pointers_}${\footnote\ftnalt \pard\plain \s45 
\f8\fs20 {\cs47\super $} When should I use references, and when should I use pointers?}}When should I use references, and when should I use pointers?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 
Old line C programmers sometimes don't like references since the reference semantics they provide isn't *explicit* in the caller's code. After a bit of C++ experience, however, one quickly realizes this "information hiding" is a
n asset rather than a liability.  In particular, reuse-centered OOP tends to migrate the level of abstraction away from the language of the machine toward the language of the problem.
\par References are usually preferred over ptrs whenever you don't need "reseating" (see early question on "How can you reseat a reference").  This usually means that references are most useful in a class' public interface.  References then typically appear on
 the skin of an object, and pointers on the inside.
\par The exception to the 
above is where a function's parameter or return value needs a "sentinel" reference.  This is usually best done by returning/taking a pointer, and giving the nil ptr (0) this special significance (references should always alias *objects*, not a dereference
d nil ptr).{\f10\fs24 
\par }\pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_are_inline_fns__What_are_their_advantages__How_are_they_declared_}${\footnote\ftnalt \pard\plain 
\s45 \f8\fs20 {\cs47\super $} What are inline fns? What are their advantages? How are they declared?}}What are inline fns? What are their advantages? How are they declared?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 An inline function is a f
unction which gets textually inserted by the compiler, much like a macro.  Like macros, performance is improved by avoiding the overhead of the call itself, and (especially!) by the compiler being able to optimize *through* the call ("procedural integrati
on").  Unlike macros, arguments to inline fns are always evaluated exactly once, so the "call" is semantically like a regular function call only faster.  Also unlike macros, argument types are checked and necessary conversions are performed correctly.

\par Beware that overuse of inline functions can cause code bloat, which can in turn have a negative performance impact in paging environments.
\par They are declared by using the "inline" keyword when the function is defined:
\par \tab {\f11 inline void f(int i, char c) \{ /*...*/ \}   //an inline function}{\f10\fs24 
\par }or by including the function definition itself within a class:
\par \tab {\f11 class X \{
\par \tab public:
\par \tab   void f(int i, char c) \{ /*...*/ \}   //inline function within a class
\par \tab \};
\par }or by defining the member function as "inline" outside the class:
\par \tab {\f11 class X \{
\par \tab public:
\par \tab   void f(int i, char c);
\par \tab \};
\par \tab //...
\par \tab inline void X::f(int i, char c) \{/*...*/\} //inline fn outside the class}{\f10\fs24 
\par }Generally speaking, a function cannot be defined as "inline" after it has been called.  Inline functions should be defined in a header file, with "outlined" functions appearing in a ".C" file (or .cpp, etc; see question on file naming conventions).{
\f10\fs24 
\par }\pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_is_a_constructor___Why_would_I_ever_use_one_}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {
\cs47\super $} What is a constructor?  Why would I ever use one?}}What is a constructor?  Why would I ever use one?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 
Objects are required to establish and maintain their own internal coherence. The "maintaining" part is done by ensuring self-consistency is restored after any operation completes (ex: by incrementing the link count after adding a new link to a linked list
).  The part about "establishing coherence" is the job of a constructor.
\par Constructors are like "init functions"; they build a valid object.  The constructor turns a pile of incoherent arbitrary bits into a living object.
\par Minimally it initializes any internally used fields that are needed, but it may also allocate resources (memory, files, semaphores, sockets, ...).
\par A constructor is like a "factory": it builds objects from dust.
\par "ctor" is a typical abbreviation for constructor.{\f10\fs24 
\par }\pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_are_destructors_really_for___Why_would_I_ever_use_them_}${\footnote\ftnalt \pard\plain \s45 
\f8\fs20 {\cs47\super $} What are destructors really for?  Why would I ever use them?}}What are destructors really for?  Why would I ever use them?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Destructors are used to release any resources allocated
 by the object's constructor.  Ex: a Lock class might lock a semaphore, and the destructor will release that semaphore.  The usual "resource" being acquired in a constructor (and subsequently released in a destructor) is dynamically allocated memory.

\par "dtor" is a typical abbreviation for destructor{\f10\fs24 
\par }\pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_is_operator_overloading_}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super $}
 What is operator overloading?}}What is operator overloading?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Operator overloading allows the basic C/C++ operators to have user-defined meanings on user-defined types (classes).  They are syntactic sugar for equivalent function calls; ex:
\par \tab {\f11 class X \{
\par \tab   //...
\par \tab public:
\par \tab   //...
\par \tab \};
\par \tab X add(X, X);\tab //a top-level function that adds two X's
\par \tab X mul(X, X);\tab //a top-level function that multiplies two X's
\par \tab X f(X a, X b, X c)
\par \tab \{
\par \tab   return add(add(mul(a,b), mul(b,c)), mul(c,a));
\par \tab \}}{\f10\fs24 
\par }Now merely replace "add" with "operator+" and "mul" with "operator*":{\f10\fs24 
\par }\tab {\f11 X operator+(X, X);\tab //a top-level function that adds two X's
\par \tab X operator*(X, X);\tab //a top-level function that multiplies two X's
\par \tab X f(X a, X b, X c)
\par \tab \{
\par \tab   return a*b + b*c + c*a;
\par \tab \}}{\f10\fs24 
\par }\pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_operators_can_cannot_be_overloaded_}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super $}
 What operators can/cannot be overloaded?}}What operators can/cannot be overloaded?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 
Most can be overloaded. The only C operators that can't be are "." and "?:" (and "sizeof", which is technically an operator).  C++ adds a few of its own operators, most of which can be overloaded except "::" and ".*".
\par Here's an example of the subscript operator (it returns a reference). First withOUT operator overloading:
\par \tab {\f11 class Vec \{
\par \tab   int data[100];
\par \tab public:
\par \tab   int& elem(unsigned i) \{ if (i>99) error(); return data[i]; \}
\par \tab \};
\par \tab main()
\par \tab \{
\par \tab   Vec v;
\par \tab   v.elem(10) = 42;
\par \tab   v.elem(12) += v.elem(13);
\par \tab \}
\par }Now simply replace "elem" with "operator[]":
\par \tab {\f11 class Vec \{
\par \tab   int data[100];
\par \tab public:
\par \tab   int& operator[](unsigned i) \{ if (i>99) error(); return data[i]; \}
\par \tab \};   //^^^^^^^^^^--formerly "elem"
\par \tab main()
\par \tab \{
\par \tab   Vec v;
\par \tab   v[10] = 42;
\par \tab   v[12] += v[13];
\par \tab \}
\par }\pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} Can_I_create_a______operator_for__to_the_power_of__operations_}${\footnote\ftnalt \pard\plain \s45 
\f8\fs20 {\cs47\super $} Can I create a \ldblquote **' operator for \ldblquote to-the-power-of' operations?}}Can I create a "**" operator for "to-the-power-of" operations?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 No.
\par The names of, precedence of, associativity of, and arity of operators is fixed by the language.  There is no "**" operator in C++, so you cannot create one for a class type.
\par If you doubt the wisdom of this approach, consider the following code:
\par \tab x = y ** z;
\par Looks like your power operator?  Nope.  z may be a ptr, so this is actually:
\par \tab x = y * (*z);
\par Lexical analysis groups characters into tokens at the lowest level of the compiler's operations, so adding new operators would present an implementation nightmare (not to mention the increased maintenance cost to read the code!).
\par Besides, operator overloading is just syntactic sugar for function calls.  It does not add fundamental power to the language (although this particular syntactic sugar can be very sweet, it is not fundamentally necessary).  I suggest you overload "pow(base
,exponent)", for which a double precision version is provided by the ANSI-C <math.h> library.
\par By the way: operator^ looks like a good candidate for to-the-power-of, but it has neither the proper precedence nor associativity.{\f10\fs24 
\par }\pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_is_a__friend__}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super $} What is a \ldblquote 
friend'?}}What is a "friend"?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Friends can be either functions or other classes.  The class grants friends unlimited access privileges.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} Do__friends__violate_encapsulation_}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super $} Do 
\ldblquote friends' violate encapsulation}}Do "friends" violate encapsulation?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 
Friends can be looked at three ways: (1) they are not class members and they therefore violate encapsulation of the class members by their mere existence, (2) a class' friends are absorbed into that class' encapsulation barrier, and (3) any time anyone wa
nts to do anything tricky they textedit the header file and add a new friend so they can get right in there and fiddle 'dem bits.
\par No one argues that (3) is a Good Thing, and for good reasons. The arguments for (1) always boil down to the rather arbitrary an
d somewhat naive view that a class' member functions "should" be the *only* functions inside a class' encapsulation barrier.  I have not seen this view bear fruit by enhancing software quality.  On the other hand, I have seen (2) bear fruit by lowering th
e *overall* coupling in a software system.  Reason: friends can be used as "liaisons" to provide safe, screened access for the whole world, perhaps in a way that the class syntactically or semantically isn't able to do for itself.
\par Conclusion: friend functio
ns are merely a syntactic variant of a class' public access functions.  When used in this manner, they don't violate encapsulation any more than a member function violates encapsulation.  Thus a class' friends and members *are* the encapsulation barrier, 
as defined by the class itself.
\par I've actually seen the "friends always violate encapsulation" view *destroy* encapsulation: programmers who have been taught that friends are inherently evil want to avoid them, but they have another class or fn that needs ac
cess to some internal detail in the class, so they provide a member fn which exposes the class' internal details to the PUBLIC!  Private decisions should stay private, and only those inside your encapsulation barrier (your members, friends, and [for "prot
ected" things] your subclasses) should have access.{\f10\fs24 
\par }\pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_are_some_advantages_disadvantages_of_using_friends_}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 
{\cs47\super $} What are some advantages/disadvantages of using friends?}}What are some advantages/disadvantages of using friends?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 The advantage of usi
ng friends is generally syntactic.  Ie: both a member fnand a friend are equally privileged (100% vested), but a friend function can be called like f(obj), where a member is called like obj.f().  When it's not for syntactic reasons (which is not a "bad" r
eason -- making an abstraction's syntax more readable lowers maintenance costs!), friends are used when two or more classes are designed to be more tightly coupled than you want for "joe public" (ex: you want to allow class "ListIter" to have more privile
ge with class "List" than you want to give to "main()").
\par Friends have three disadvantages.  The first disadvantage is that they add to the global namespace.  In contrast, the namespace of member functions is buried within the class, reducing the chance for namespace collisions for functions.
\par The second disadvantage is that they aren't inherited.  That is, the "friendship privilege" isn't inherited.  This is actually an advantage when it
\par comes to encapsulation.  Ex: I may declare you as my friend, but that doesn't mean I trust your kids.{\f10\fs24 
\par }
The third disadvantage is that they don't bind dynamically.  Ie: they don't respond to polymorphism.  There are no virtual friends; if you need one, have a friend call a hidden (usually "protected:") virtual member fn.  Friends that take a ptr/ref to a cl
ass can also take a ptr/ref to a publically derived class object, so they act as if they are inherited, but the friendship *rights* are not inherited (the friend of a base has no special access to a class derived from that base).{\f10\fs24 
\par }\pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_does_it_mean_that__friendship_is_neither_inherited_nor_transitive__}${\footnote\ftnalt 
\pard\plain \s45 \f8\fs20 {\cs47\super $} What does it mean that \ldblquote friendship is neither inherited nor transitive'?}}What does it mean that "friendship is neither inherited nor transitive"?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 This is speaking of the access privileges granted when a class declares a friend.
\par The access privilege of friendship is not inherited:
\par \tab  * I may trust you, but I don't necessarily trust your kids.
\par \tab  * My friends aren't necessarily friends of my kids.
\par \tab  * Class "Base" declares f() to be a friend, but f() has no special access rights with class "Derived".
\par The access privilege of friendship is not transitive:{\f10\fs24 
\par }\pard \li144\ri144\sb40\sa60\sl240\slmult0\tx360 \tab \tab  * I may trust you, and you may trust Sam, but that doesn't necessarily mean that I trust Sam.{\f10\fs24 
\par }\pard \li144\ri144\sb40\sa60\sl240\slmult0  \tab  * A friend of a friend is not necessarily a friend.{\f10\fs24 
\par }\pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} When_would_I_use_a_member_function_as_opposed_to_a_friend_function_}${\footnote\ftnalt \pard\plain 
\s45 \f8\fs20 {\cs47\super $} When would I use a member function as opposed to a friend function?}}When would I use a member function as opposed to a friend function?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Use a member when you can, and a friend when you have to.
\par Like in real life, my family members have certain privileges that my friends do not have (ex: my family members inherit from me, but my friends do not, etc). To grant privileged access to a function, you need either a friend or a member; there is no addit
ional loss of encapsulation one way or the other.  Sometimes friends are syntactically better (ex: in class "X", friend fns allow the "X" param to be second, while members require it to be first).  Another good use of frie
nd functions are the binary infix arithmetic operators.  Ex: "aComplex + aComplex" probably should be defined as a friend rather than a member, since you want to allow "aFloat + aComplex" as well (members don't allow promotion of the left hand arg, since 
that would change the class of the object that is the recipient of the message).
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} How_can_I_provide_printing_for_a__class_X__}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super $
} How can I provide printing for a \ldblquote class X'?}}How can I provide printing for a "class X"?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Provide a friend operator<<:
\par  {\f11    class X \{
\par       int i;    //just for illustration
\par     public:
\par       friend ostream& operator<<(ostream& o, const X& x) \{ return o << x.i; \}
\par       //...
\par     \};}{\f10\fs24 
\par }We use a friend rather than a member since the "X" parameter is 2nd, not 1st.
\par Input is similar, but the signature is:
\par {\f11 \tab istream& operator>> (istream& i, X& x);  //not "const X& x" !!}{\f10\fs24 
\par }\pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} Why_should_I_use__iostream_h__instead_of_the_traditional__stdio_h__}${\footnote\ftnalt \pard\plain 
\s45 \f8\fs20 {\cs47\super $} Why should I use <iostream.h> instead of the traditional <stdio.h>?}}Why should I use <iostream.h> instead of the traditional <stdio.h>?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 See next question.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} Printf_scanf_weren_t_broken__why__fix__them_with_ugly_shift_operators_}${\footnote\ftnalt \pard\plain 
\s45 \f8\fs20 {\cs47\super $} Printf/scanf weren't broken; why \ldblquote fix' them with ugly shift operators?}}Printf/scanf weren't broken; why "fix" them with ugly shift operators?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 
The overloaded shift operator syntax is strange at first sight, but it quickly grows on you.  However syntax is just syntax; the real issues are deeper.  Printf is arguably not broken, and scanf is perhaps livable despite being error pro
ne, however both are limited with respect to what C++ I/O can do.  C++ I/O (left/right shift) is, relative to C (printf/scanf):
\par \pard \li144\ri144\sb40\sa60\sl240\slmult0\tx360 \tab  type safe -- type of object being I/O'd is known statically by the compiler rather than via dynamically tested '%' fields
\par \tab less error prone -- redundant info has greater chance to get things wrong C++ I/O has no redundant '%' tokens to get right
\par \tab faster -- printf is basi
cally an "interpreter" of a tiny language whose constructs mainly include '%' fields.  the proper low-level routine is chosen at runtime based on these fields.  C++ I/O picks these routines statically based on actual types of the args
\par \tab extensible -- perhaps most important of all, the C++ I/O mechanism is Extensible to new user-defined data types (imagine the chaos if
\par everyone was simultaneously adding new incompatible '%' fields to printf and scanf?!).  Remember: we want to make user-defined \tab types (classes) look and act like "built-in" types.
\par \tab 
subclassable -- ostream and istream (the C++ replacements for FILE*) are real classes, and hence subclassable.  This means you can have other user defined things that look and act like streams, yet that do whatever strange and wonderful things you want. 
 You automatically
\par get to use the zillions of lines of I/O code written by users you\tab don't even know, and they don't need to know about your "extended
\par stream' class.  Ex: you can have a "stream" that writes to a memory area (incore formatting provided by the standard class "strstream"),
\par or you could have it use the stdio buffers, or [you name it...].{\f10\fs24 
\par }\pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} Does__delete_ptr__delete_the_ptr_or_the_pointed_to_data_}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 
{\cs47\super $} Does \ldblquote delete ptr' delete the ptr or the pointed-to-data?}}Does "delete ptr" delete the ptr or the pointed-to-data?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 The pointed-to-data.
\par "delete" really means "delete the thing pointed to by."  The same abuse of English occurs when "free"ing the memory pointed to by a ptr in C ("free(p)" really means free_the_stuff_pointed_to_by(p)").
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} Can_I_free___ptrs_alloc_d_with__new__or__delete__ptrs_alloc_d_w__malloc___}${\footnote\ftnalt 
\pard\plain \s45 \f8\fs20 {\cs47\super $} Can I free() ptrs alloc'd with \ldblquote new' or \ldblquote delete' ptrs alloc'd w/ malloc()?}}Can I free() ptrs alloc'd with "new" or "delete" ptrs alloc'd w/ malloc()?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 No.
\par It is perfectly legal, moral, and wholesome to use malloc/free and new/delete in the same program, but it is illegal, immoral, and despicable to free a pointer allocated via new, or to delete a pointer allocated via malloc.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} Why_should_I_use__new__instead_of_trustworthy_old_malloc___}${\footnote\ftnalt \pard\plain \s45 
\f8\fs20 {\cs47\super $} Why should I use \ldblquote new' instead of trustworthy old malloc()?}}Why should I use "new" instead of trustworthy old malloc()?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Constructors/destructors, type safety, overridability.
\par Constructors/destructors: unlike "malloc(sizeof(Fred))", "new Fred()" calls Fred's constructor.  Similarly, "delete p" calls "*p"'s destructor.
\par Type safety: malloc() returns a "void*" which isn't type safe.  "new Fred()" returns a ptr of the right type (a "Fred*").
\par Overridability: "new" is an operator that can be overridden by a class, while "malloc" is not overridable on a per-class basis.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} Why_doesn_t_C___have_a__realloc____along_with__new__and__delete__}${\footnote\ftnalt \pard\plain \s45 
\f8\fs20 {\cs47\super $} Why doesn't C++ have a \ldblquote realloc()' along with \ldblquote new' and \ldblquote delete'?}}Why doesn't C++ have a "realloc()" along with "new" and "delete"?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 To save you from disaster.
\par When realloc() has to copy the allocation, it uses a BITWISE copy operation, which will tear most C++ objects to shreds.  C++ objects should be allowed to copy themselves: they use their own copy constructor or assignment operator.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} How_do_I_allocate___unallocate_an_array_of_things_}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {
\cs47\super $} How do I allocate / unallocate an array of things?}}How do I allocate / unallocate an array of things?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Use new[] and delete[]:
\par \tab {\f11 Thing* p = new Thing[100];
\par \tab //...
\par \tab delete [] p; //older compilers require you to use "delete[100]p"
\par }Any time you allocate an array of things (ie: any time you use the "[...]" in the "new" expression) you *!*MUST*!* use the "[]" in the "delete" statement.
\par The fact that there is no syntactic difference between a ptr to a thing and a ptr to an array of things is an artifact we inherited from C.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_if_I_forget_the______when__delete_ing_array_allocated_via__new_X_n___}${\footnote\ftnalt 
\pard\plain \s45 \f8\fs20 {\cs47\super $} What if I forget the \ldblquote []' when \ldblquote delete'ing array allocated via \ldblquote new X[n]'?}}What if I forget the "[]" when "delete'ing array allocated via "new X[n]"?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 All life comes to a catastrophic end.
\par It is the programmer's --not the compiler's-- responsibility to get the connection between new[] and delete[] correct.  If you get it wrong, neither a compile-time nor a run-time error message will be generated by the compiler. Heap corruption is a likely
 result.  Or worse.  Your program will probably die.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_s_the_best_way_to_create_a___define_macro__for__NULL__in_C___}${\footnote\ftnalt \pard\plain \s45 
\f8\fs20 {\cs47\super $} What's the best way to create a \ldblquote #define macro_ for _NULL_ in C___}}What's the best way to create a "#define macro" for "NULL" in C++?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 The best way is: don't do it.
\par The most portable way to compare against the nil ptr is to compare against "0". Some programmers use a #define to set NULL to "0", but that can conflict with the way the standard libraries #define NULL.  There is no portable way to define a "const" ptr ca
lled "NULL" that can be compared against any arbitrary ptr -- the literal "0" is acceptable for this however.{\f10\fs24 
\par }\pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} How_can_I_handle_a_constructor_that_fails_}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super $
} How can I handle a constructor that fails?}}How can I handle a constructor that fails?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Throw an exception.
\par Constructors don't have a return type, so it's not possible to use error codes. The best way to signal constructor failure is therefore to throw an exception.
\par Before C++ had exceptions, we signaled constructor failure by putting the object into a "half baked" state (e.g., by setting an internal status bit).There was a query ("inspector") method to check this bit, that allowed clients to discover whether they ha
d a live object.  Other member functions would also check this bit, and, if the object wasn't really alive, do a no-op (or perhaps something more obnoxious such as "abort()"). This was really ugly.{\f10\fs24 
\par }\pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 
\par {\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} How_can_I_compile_out_my_debugging_print_statements_}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super $} How can I compile-out my debugging print statements?}}How can I
 compile-out my debugging print statements?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 This will NOT work, since comments are parsed before the macro is expanded:
\par \tab {\f11 #ifdef DEBUG_ON
\par \tab   #define  DBG
\par \tab #else
\par \tab   #define  DBG  //
\par \tab #endif
\par \tab DBG cout << foo;}{\f10\fs24 
\par }This is the simplest technique:
\par \tab {\f11 #ifdef DEBUG_ON
\par \tab   #define  DBG(anything)  anything
\par \tab #else
\par \tab   #define  DBG(anything)  /*nothing*/
\par \tab #endif}{\f10\fs24 
\par }Then you can say:
\par \tab {\f11 //...
\par \tab DBG(cout << "the value of foo is " << foo << '\\n');
\par \tab //                                                ^-- ";' outside ()}{\f10\fs24 
\par }Any commas in your "DBG()" statement must be enclosed in a "()":
\par \tab {\f11 DBG(i=3, j=4);\tab //<---- C-preprocessor will generate error message
\par \tab DBG(i=3; j=4);\tab //<---- ok}{\f10\fs24 
\par }There are also more complicated techniques that use variable argument lists, but these are primarily useful for "printf()' style (see question on the pros and cons of <iostream.h> as opposed to <stdio.h> for more).
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_is__const_correctness__}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super $} What is 
\ldblquote const correctness'?}}What is "const correctness"?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 A good thing.
\par Const correctness uses the keyword "const" to ensure const objects don't get mutated.  E.g., if function "f()" accepts a "String", and "f()" wants to promise not to change the "String", you:
\par \tab * can either pass by value:  void  f(      String  s   )  \{ /*...*/ \}
\par  \tab * or by constant reference:  void  f(const String& s   )  \{ /*...*/ \}
\par  \tab * or by constant pointer:    void  f(const String* sptr)  \{ /*...*/ \}
\par  \tab * but {\b NOT} by non-const ref:  void  f(      String& s   )  \{ /*...*/ \}
\par  \tab * {\b NOR} by non-const pointer:  void  f(      String* sptr)  \{ /*...*/ \}
\par Attempted changes to "s" within a fn that takes a "const String&" are flagged as compile-time errors; neither run-time space nor speed is degraded.
\par Declaring the "constness" of a parameter is just another form of type safety. It is almost as if a constant String, for
 example, "lost" its various mutative operations.  If you find type safety helps you get systems correct (it does; especially in large systems), you'll find const correctness helps also.{\f10\fs24 
\par }\pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} Is__const_correctness__a_good_goal_}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super $} Is 
\ldblquote const correctness' a good goal?}}Is "const correctness" a good goal?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 
Declaring the "constness" of a parameter is just another form of type safety.  It is almost as if a constant String, for example, "lost" its various mutative operations.  If you find type safety helps you get s
ystems correct (especially large systems), you'll find const correctness helps also.
\par Short answer: yes, const correctness is a good goal.{\f10\fs24 
\par }\pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} Is__const_correctness__tedious_}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super $} Is 
\ldblquote const correctness' tedious?}}Is "const correctness" tedious?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 
Type safety requires you to annotate your code with type information.  In theory, expressing this type information isn't necessary -- witness untyped languages as an example of this.  However in practice, programmers often know in their heads a lot of int
eresting information about their code, so type safety (and, by extension, const correctness) merely provide structured ways to get this information into their keyboards.
\par Short answer: yes, const correctness is tedious.{\f10\fs24 
\par }\pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} Should_I_try_to_get_things_const_correct__sooner__or__later__}${\footnote\ftnalt \pard\plain \s45 
\f8\fs20 {\cs47\super $} Should I try to get things const correct \ldblquote sooner' or \ldblquote later'?}}Should I try to get things const correct "sooner" or "later"?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 At the very, very, VERY beginning.
\par Back-patching const correctness results in a snowball effect: every "const" you add "over here" requires four more to be added "over there."
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_is_a__const_member_function__}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super $}
 What is a \ldblquote const member function'?}}What is a "const member function"?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 A member function that inspects (rather than mutates) its object.
\par      class Fred \{
\par      public:
\par        void f() const;
\par      \};      // ^^^^^--- this implies "fred.f()" won't change "fred"
\par This m
eans that the ABSTRACT (client-visible) state of the object isn't going to change (as opposed to promising that the "raw bits of the object"s struct aren't going to change).  C++ compilers aren't allowed to take the "bitwise" interpretation, since a non-c
onst alias could exist which could modify the state of the object (gluing a "const" ptr to an object doesn't promise the object won't change; it promises only that the object won't change VIA THAT POINTER).
\par "const" member functions are often called "inspectors."  Non-"const" member functions are often called "mutators."{\f10\fs24 
\par }\pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_is_an__inspector____What_is_a__mutator__}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {
\cs47\super $} What is an \ldblquote inspector'?  What is a \ldblquote mutator'?}}What is an "inspector"?  What is a "mutator"?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20  An inspector inspects and a mutator mutates.  These different categories of member fns are distinguished by whether the member fn is "const" or not.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_is__casting_away_const_in_an_inspector__and_why_is_it_legal_}${\footnote\ftnalt \pard\plain \s45 
\f8\fs20 {\cs47\super $} What is \ldblquote casting away const in an inspector' and why is it legal?}}What is "casting away const in an inspector" and why is it legal?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 
In current C++, const member fns are allowed to "cast away the const-ness of the "this" ptr".  Programmers use (some say "misuse") this to tickle internally used counters, cache values, or some other non-client-visible change.  Since C++ allows you to use
 const member fns to indicate the abstract/meaning-wise state of the object doesn't change (as opposed to the concrete/bit-wise state), the "meaning" of the object shouldn't change during a const member fn.
\par Those who believe "const" member fns shouldn't be allowed to change the bits of the struct itself call the "abstract const" view "Humpty Dumpty const" (Humpty Dumpty said that words mean what he wants them to mean).  The response is that a class' public i
nterface *should* mean exactly what the class designer wants it to mean, in Humpty Dumpty's words, "nothing more and nothing less".  If the class designer says that accessing the length of a List doesn't change the List, then one can access the length of
 a "const" List (even though the "len()"member fn may internally cache the length for future accesses).
\par Some proposals are before the ANSI/ISO C++ standards bodies to provide syntax that allows individual data members to be designated as "can be modified in a const member fn" using a prefix such as "~const".  This would blend the best of the "give the compi
ler a chance to cache data across a const member fn", but only if aliasing can be solved (see next question).
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} But_doesn_t__cast_away_const__mean_lost_optimization_opportunities_}${\footnote\ftnalt \pard\plain 
\s45 \f8\fs20 {\cs47\super $} But doesn't 'cast away const' mean lost optimization opportunities?}}But doesn't "cast away const" mean lost optimization opportunities?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 
If the object is constructed in the scope of the const member fn invocation, and if all the non-const member function invocations between the object's construction and the const member fn invocation are statically bound, and if every one of these invocati
ons is also "inline"d, and if the ctor itself is "inline", and if any member fns the ctor
 calls are inline, then the answer is "Yes, the soon-to-be-standard interpretation of the language would prohibit a very smart compiler from detecting the above scenario, and the register cache would be unnecessarily flushed".  The reader should judge whe
ther the above scenario is common enough to warrant a language change which would break existing code.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_is_inheritance_}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super $} What is inheritance?}
}What is inheritance?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Inheritance is what separates abstract data type (ADT) programming from OOP. It is n
ot a "dark corner" of C++ by any means.  In fact, everything discussed so far could be simulated in your garden variety ADT programming language (ex: Ada, Modula-2, C [with a little work], etc).  Inheritance and the consequent polymorphism are the two big
 additions which separate a language like Ada from an object-oriented programming language.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} Ok__ok__but_what_is_inheritance_}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super $}
 Ok, ok, but what is inheritance?}}Ok, ok, but what is inheritance?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Human beings abstract things on two dimensions: part-of and
 kind-of.  We say that a Ford Taurus is-a-kind-of-a Car, and that a Ford Taurus has parts such as Engine, Tire, etc.  The part-of hierarchy has been a first class part of software since the ADT style became relevant, but programmers have had to whip up th
eir own customized techniques for simulating kind-of (usually in an ad hoc manner).  Inheritance changes that; it adds "the other" major dimension of decomposition.
\par An example of "kind-of decomposition", consider the genus/species biology charts.  Knowing the internal parts of various fauna and flora is important for certain applications, but knowing the groupings (kinds, categories) is equally important.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} How_do_you_express_inheritance_in_C___}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super $}
 How do you express inheritance in C++?}}How do you express inheritance in C++?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 By the ": public" syntax:
\par      class Car : public Vehicle \{
\par              //^^^^^^^^---- ": public" is pronounced "is-a-kind-of-a"
\par        //...
\par      \};
\par We state the above relationship in several ways:
\par  \tab * Car is "a kind of a" Vehicle
\par  \tab * Car is "derived from" Vehicle
\par  \tab * Car is "a specialized" Vehicle
\par  \tab * Car is the "subclass" of Vehicle
\par  \tab * Vehicle is the "base class" of Car
\par  \tab * Vehicle is the "superclass" of Car (this not as common in the C++ community)
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_is__incremental_programming__}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super $}
 What is \ldblquote incremental programming'?}}What is "incremental programming"?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 In addition to being an abstraction mechanism that makes is-a-kind-of relationships explicit, inheritance can also be used as a means of "incremental programming".  A derived cl
ass inherits all the representation (bits) of its base class, plus all the base class' mechanism (code).  Another device (virtual functions, described below) allows derived classes to selectively override some or all of the base class' mechanism (replace 
and/or enhance the various algorithms).
\par This simple ability is surprisingly powerful: it effectively adds a "third dimension" to programming.  After becoming fluent in C++, most programmers find languages like C and Ada to be "flat" (a cute little book, "Fl
atland", aptly describes those living in a two dimensional plane, and their disbelief about a strange third dimension that is somehow neither North, South, East nor West, but is "Up").{\f10\fs24 
\par }
As a trivial example, suppose you have a Linked List that is too slow, and you wish to cache its length.  You could "open up" the List "class" (or "module"), and modify it directly (which would certainly be appropriate for such a simple situation), but su
ppose the List's physical size is critical, and some important client ca
nnot afford to add the extra machine word to every List. Another option would be to textually copy the List module and modify the copy, but this increases the amount of code that must be maintained, and also presumes you have access to the internal source
 code of the List module.  The OO solution is to realize that a List that caches its length is-a-kind-of-a List, so we inherit:{\f10\fs24 
\par }\tab {\f11 class FastList : public List \{
\par \tab   int length;\tab //cache the length here
\par \tab public:
\par \tab   //override operations so the cache stays "hot"
\par \tab \};}{\f10\fs24 
\par }\pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} Should_I_pointer_cast_from_a_derived_class_to_its_base_class_}${\footnote\ftnalt \pard\plain \s45 
\f8\fs20 {\cs47\super $} Should I pointer-cast from a derived class to its base class?}}Should I pointer-cast from a derived class to its base class?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Yes.
\par A derived class is a specialized version of the base class ("Derived is a kind-of Base").  The upward conversion is perfectly safe, and happens all the time (if I am pointing at a car, I am in fact pointing at a vehicle):
\par      void f(Vehicle* v);
\par      void g(Car* c) \{ f(c); \} //perfectly safe; no cast
\par Note that the answer to this FAQ assumes we're talking about "public" inheritance; see below on "private/protected" inheritance for "the other kind".{\f10\fs24 
\par }\pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} Derived______Base__works_ok__why_doesn_t_Derived_______Base___work_}${\footnote\ftnalt \pard\plain 
\s45 \f8\fs20 {\cs47\super $} Derived* --> Base* works ok; why doesn't Derived** --> Base** work?}}Derived* --> Base* works ok; why doesn't Derived** --> Base** work?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 C++ allows a Derived* to be converted to a Base*, since a Derived object is a kind of a Base object.  However trying to convert a Derived** to a Base** is (c
orrectly) flagged as an error (if it was allowed, the Base** could be dereferenced (yielding a Base*), and the Base* could be made to point to an object of a DIFFERENT derived class.  This would be an error.
\par As a corollary, an array of Deriveds is-NOT-a-kind-of array of Bases.  At Paradigm Shift, Inc. we use the following example in our C++ training sessions:
\par                "A bag of apples is NOT a bag of fruit".
\par If a bag of apples COULD be passed as a bag of fruit, someone could put a banana into the bag of apples!
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} Does_array_of_Derived_is_NOT_a_kind_of_array_of_Base_mean_arrays_are_bad_}${\footnote\ftnalt 
\pard\plain \s45 \f8\fs20 {\cs47\super $} Does array-of-Derived is-NOT-a-kind-of array-of-Base mean arrays are bad?}}Does array-of-Derived is-NOT-a-kind-of array-of-Base mean arrays are bad?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Yes, "arrays are evil" (jest kidd'n :-).
\par There's a very subtle problem with using raw built-in arrays.  Consider this:
\par      void f(Base* arrayOfBase)
\par      \{
\par        arrayOfBase[3].memberfn();
\par      \}
\par      main()
\par      \{
\par        Derived arrayOfDerived[10];
\par        f(arrayOfDerived);
\par      \}
\par The compiler thinks this is perfectly type-safe, since it can convert a Derived* to a Base*.  But in reality it is horrendously evil: since Derived might be larger than Base, the array index in f() not only isn't type safe, it may not even be pointing at 
a real object!  In general it'll be pointing somewhere into the innards of some poor Derived.
\par The root problem is that C++ can't distinguish between a ptr-to-a-thing and a ptr-to-an-array-of-things.  Naturally C++ "inherited" this feature from C.
\par NOTE: if we had used an array-like CLASS instead of using a raw array (e.g., an "Array<T>" rather than a "T[]"), this problem would have been properly trapped as an error at compile time rather than at run-time.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_is_a__virtual_member_function__}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super $}
 What is a \ldblquote virtual member function'?}}What is a "virtual member function"?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 
A virtual function allows derived classes to replace the implementation provided by the base class.  The compiler ensures the replacement is always called whenever the object in question is actually of the derived class, even if the object is accessed by 
a base pointer rather than a derived pointer. This allows algorithms in the base class to be replaced in the derived class, even if users don't know about the derived class.
\par Note: the derived class can partially replace ("override") the base class method (the derived class method can invoke the base class version if desired).
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_s_the_big_deal_of_separating_interface_from_implementation_}${\footnote\ftnalt \pard\plain \s45 
\f8\fs20 {\cs47\super $} What's the big deal of separating interface from implementation?}}What's the big deal of separating interface from implementation?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 
Separating interface from implementation is a key to reusable software. Interfaces are a company's most valuable resources.  Designing an interface takes longer than whipping together a concrete class which fulfills that interface.  Furthe
rmore interfaces require the resources of more expensive people (for better and worse, most companies separate "designers" from "coders").  Since they're so valuable, they should be protected from being tarnished by data structures and other artifacts of 
the implementation (any data structures you put in a class can never be "revoked" by a derived class, which is why you want to "separate" the interface from the implementation).{\f10\fs24 
\par }\pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_is_dynamic_dispatch___Static_dispatch_}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super 
$} What is dynamic dispatch?  Static dispatch?}}What is dynamic dispatch?  Static dispatch?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 In the following discussion, "ptr" means either a pointer or a reference.
\par When you have a ptr to an object, there are two distinct types in question: the static type of the ptr, and the dynamic type of the pointed-to object (the object may actually be of a class that is derived from the class of the ptr).
\par The "legality" of the call is checked based on the static type of the ptr, which gives us static type safety (if the type of the ptr can handle t
he member fn, certainly the pointed-to object can handle it as well, since the pointed-to object is of a class that is derived from the ptr's class).
\par Suppose ptr's type is "List" and the pointed-to object's type is "FastList". Suppose the fn "len()" is provided in "List" and overridden in "FastList".  The question is: which function should actually be invoked: the function attached to the pointer's typ
e ("List::len()") or the function attached to the object itself ("FastList::len()")?
\par If "len()" is a virtual function, as it would be in the above case, the fn attached to the object is invoked.  This is called "dynamic binding", since the actual code being called is determined dynamically (at run time).
\par On the other hand, if "len()" were non-virtual, the dispatch would be resolved statically to the fn attached to the ptr's class.{\f10\fs24 
\par }\pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} Can_I_override_a_non_virtual_fn_}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super $}
 Can I override a non-virtual fn?}}Can I override a non-virtual fn?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 It's legal, but it ain't moral.
\par Experienced C++ programmers will sometimes red
efine a non-virtual fn for efficiency (the alternate implementation might make better use of the derived class' resources), or to get around the hiding rule (see below, and ARM sect.13.1).  However the client-visible effects must be IDENTICAL, since non-v
irtual fns are dispatched based on the static type of the ptr/ref rather than the dynamic type of the pointed-to/referenced object.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} Can_I__revoke__or__hide__public_member_fns_inherited_from_my_base_class_}${\footnote\ftnalt 
\pard\plain \s45 \f8\fs20 {\cs47\super $} Can I \ldblquote revoke' or \ldblquote hide' public member fns inherited from my base class?}}Can I "revoke" or "hide" public member fns inherited from my base class?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Never never never do this.  Never.  NEVER!
\par Attempting to hide (eliminate, revoke) inherited public member functions is an all-too-common design error.  It usually stems from muddy thinking.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} Is_a__Circle__a_kind_of_an__Ellipse__}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super $}
 Is a \ldblquote Circle' a kind-of an \ldblquote Ellipse'?}}Is a "Circle" a kind-of an "Ellipse"?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Not if Ellipse promises to be able to change its size asymmetrically.
\par For example, suppose Ellipse h
as a "setSize(x,y)" method, and suppose this method promises "the Ellipse's width() will be x, and its height() will be y". In this case, Circle can't be a kind-of Ellipse.  Simply put, if Ellipse can do something Circle can't, then Circle can't be a kind
 of Ellipse.
\par This leaves two potential (valid) relationships between Circle and Ellipse:
\par  \tab * Make Circle and Ellipse completely unrelated classes.
\par  \tab * Derive Circle and Ellipse from a base class representing "Ellipses that can't \tab  NECESSARILY perform an unequal-setSize operation."
\par In the first case, Ellipse could be derived from class "AsymmetricShape" (with setSize(x,y) being introduced in AsymmetricShape), and Circle could be derived from "SymmetricShape," which has a setSize(size) member fn.
\par In the second case, class "Oval" could only have "setSize(size)" which sets both the "width()" and the "height()" to "size", then derive both Ellipse and Circle from Oval.  Ellipse --but not Circle-- adds the "setSize(x,y)" operation (see the "hiding rule
" for a caveat if the same method name "setSize()" is used for both operations).
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} Are_there_other_options_to_the__Circle_is_isnot_kind_of_Ellipse__dilemma_}${\footnote\ftnalt 
\pard\plain \s45 \f8\fs20 {\cs47\super $} Are there other options to the \ldblquote Circle is/isnot kind-of Ellipse' dilemma?}}Are there other options to the "Circle is/isnot kind-of Ellipse" dilemma?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 
If you claim that all Ellipses can be squashed asymmetrically, and you claim that Circle is a kind-of Ellipse, and you claim that Circle can't be squashed asymmetrically, clearly you've got to adjust (revoke, actuall
y) one of your claims.  Thus you've either got to get rid of "Ellipse::setSize(x,y)", get rid of the inheritance relationship between Circle and Ellipse, or admit that your "Circle"s aren't necessarily circular.
\par Here are the two most common traps new OO/C++ programmers regularly fall into. They attempt to use coding hacks to cover up a broken design (they redefine Circle::setSize(x,y) to throw an exception, call "abort()", or choose the average of the two paramet
ers, or to be a no-op).  Unfortunately all these hacks will surprise users, since users are expecting "width() ==x" and "height() == y".
\par The only rational way out of this would be to weaken the promise made by Ellipse's "setSize(x,y)" (e.g., you'd have to change it to, "This method MIGHT set width() to x and height() to y, or it might do NOTHING"). Unfortunately this dilutes the contract i
nto dribble, since the user can't rely on any meaningful behavior.  The whole hierarchy therefore begins to be worthless (it's hard to convince someone to use an object if you have to shrug your shoulders when asked what the object does for them).
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} Why_can_t_I_access__private__things_in_a_base_class_from_a_derived_class_}${\footnote\ftnalt 
\pard\plain \s45 \f8\fs20 {\cs47\super $} Why can't I access \ldblquote private' things in a base class from a derived class?}}Why can't I access "private" things in a base class from a derived class?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 To protect you from future changes to the base class.
\par Derived classes do not get access to private members of a base class. This effectively "seals off" the derived class from any changes made to the private members of the base class.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_s_the_difference_between__public_____private____and__protected___}${\footnote\ftnalt \pard\plain 
\s45 \f8\fs20 {\cs47\super $} What's the difference between \ldblquote public:', \ldblquote private:', and \ldblquote protected:'?}}What's the difference between "public:", "private:", and "protected:"?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 
"Private:" is discussed in the previous section, and "public:" means "anyone can access it."  The third option, "protected:", makes a member (either data member or member fn) accessible to subclasses.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} How_can_I_protect_subclasses_from_breaking_when_I_change_internal_parts_}${\footnote\ftnalt 
\pard\plain \s45 \f8\fs20 {\cs47\super $} How can I protect subclasses from breaking when I change internal parts?}}How can I protect subclasses from breaking when I change internal parts?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 A class has two distinct interfaces for two distinct sets of clients:
\par  \tab * its "public:" interface serves unrelated classes.
\par  \tab * its "protected:" interface serves derived classes.
\par Unless you expect all your subclasses to be built by your own team, you should consider making your base
 class's bits be "private:", and use "protected:" inline access functions to access these data.  This way the private bits can change, but the derived class's code won't break unless you change the protected access functions.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} Why_does_base_ctor_get__base__s_virtual_fn_instead_of_the_derived_version_}${\footnote\ftnalt 
\pard\plain \s45 \f8\fs20 {\cs47\super $} Why does base ctor get *base*'s virtual fn instead of the derived version?}}Why does my base ctor get *base*'s virtual fn instead of the derived version?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 During the Base class's constructor, the object isn't yet a Derived, so if "Base::Base()" calls a virtual function "virt()", the "Base::virt()" will be invoked, even if "Derived::virt()" exists.

\par Similarly, during Base's destructor, the object is no longer a Derived, so when Base::~Base() calls "virt()", "Base::virt()" gets control, NOT the "Derived::virt()" override.
\par You'll quickly see the wisdom of this approach when you imagine the disaster if "Derived::virt()" touched a member object from the Derived class.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} Does_a_derived_class_dtor_need_to_explicitly_call_the_base_destructor_}${\footnote\ftnalt \pard\plain 
\s45 \f8\fs20 {\cs47\super $} Does a derived class dtor need to explicitly call the base destructor?}}Does a derived class dtor need to explicitly call the base destructor?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 No, never explicitly call a destructor (where "never" means "rarely").
\par A derived class's destructor (whether or not you explicitly define one) AUTOMATICALLY invokes the destructors for member objects and base class subobjects.  Member objects are destroyed in the reverse order they appear within the class, then base class su
bobjects are destroyed in the reverse order that they appear in the class's list of base classes.
\par You should explicitly call a destructor ONLY in esoteric situations, such as when destroying an object created by the "placement new operator."
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} How_do_you_express__private_inheritance__}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super $}
 How do you express \ldblquote private inheritance'?}}How do you express "private inheritance"?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 When you use ": private" instead of ": public".  Ex:
\par \tab {\f11 class Foo : private Bar \{
\par \tab   //...
\par \tab \};}{\f10\fs24 
\par }\pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} How_are__private_derivation__and__containment__similar__dissimilar_}${\footnote\ftnalt \pard\plain 
\s45 \f8\fs20 {\cs47\super $} How are \ldblquote private derivation' and \ldblquote containment' similar? dissimilar?}}How are "private derivation" and "containment" similar? dissimilar?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Private inheritance is a syntactic variant of composition (has-a).
\par 
\par E.g., the "car has-a engine" relationship can be expressed using composition:
\par 
\par {\f11      class Engine \{
\par      public:
\par        Engine(int numCylinders);
\par        void start();               //starts this Engine
\par      \};
\par 
\par      class Car \{
\par      public:
\par        Car() : e_(8) \{ \}      //initializes this Car with 8 cylinders
\par        void start() \{ e_.start(); \}     //start this Car by starting its engine
\par      private:
\par        Engine e_;
\par      \};}
\par 
\par The same "has-a" relationship can also be expressed using private inheritance:
\par 
\par     {\f11  class Car : private Engine \{
\par      public:
\par        Car() : Engine(8) \{ \}       //initializes this Car with 8
\par cylinders
\par        Engine::start;         //start this Car by starting its engine
\par      \};}
\par 
\par There are several similarities between these two forms of composition:
\par \tab * in both cases there is exactly one Engine member object contained in a Car.
\par \tab * in neither case can users (outsiders) convert a Car* to an Engine*.
\par 
\par There are also several distinctions:
\par \tab * the first form is needed if you want to contain several Engines per Car.
\par  \tab * the second form can introduce unnecessary multiple inheritance.
\par  \tab * the second form allows members of Car to convert a Car* to an Engine*.
\par  \tab * the second form allows access to the "protected" members of the base class.
\par  \tab * the second form allows Car to override Engine's virtual functions.
\par 
\par Note that private inheritance is usually used to gain access into the "protected:" members of the base class, but this is usually a short-term solution (translation: a band-aid; see below).
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} Should_I_pointer_cast_from_a__privately__derived_class_to_its_base_class_}${\footnote\ftnalt 
\pard\plain \s45 \f8\fs20 {\cs47\super $} Should I pointer-cast from a \ldblquote privately' derived class to its base class?}}Should I pointer-cast from a "privately" derived class to its base class?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 The short answer: no, but yes too (better read the long answer!)
\par >From "inside" the privately derived class (ie: in the body of members or friends of the privately derived class), the relationship to the base class is known, and the upward conversion from PrivatelyDer* to Base* (or PrivatelyDer& to Base&) is safe and d
oesn't need a cast.
\par >From "outside" the privately derived class, the relationship to "Base" is a "private" decision of "PrivatelyDer", so the conversion requires a cast. Clients should not exercise this cast, since private derivati
on is a private implementation decision of the privately derived class, and the coercion will fail after the privately derived class privately chooses to change this private implementation decision.
\par Bottom line: only a class and its friends have the right to convert a ptr to a derived class into a ptr to its private base class.  They don't need a cast, since the relationship with the base class is accessible to them.  No one else can convert such ptr
s without pointer-casts, so no one else should.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} Should_I_pointer_cast_from_a__protected__derived_class_to_its_base_class_}${\footnote\ftnalt 
\pard\plain \s45 \f8\fs20 {\cs47\super $} Should I pointer-cast from a \ldblquote protected' derived class to its base class?}}Should I pointer-cast from a "protected" derived class to its base class?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Generally, No.
\par From a method or friend of a privately derived class, the relationship to the base class is known, and the upward conversion from PrivatelyDer* to Base* (or PrivatelyDer& to Base&) is safe; no cast is needed or recommended.
\par However users of PrivateDer should avoid this unsafe conversion, since it is based on a "private" decision of PrivateDer, and is subject to change without notice.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_are_the_access_rules_with__private__and__protected__inheritance_}${\footnote\ftnalt \pard\plain 
\s45 \f8\fs20 {\cs47\super $} What are the access rules with \ldblquote private' and \ldblquote protected' inheritance?}}What are the access rules with "private" and "protected" inheritance?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Take these classes as examples:
\par {\f11 \tab class B \{ /*...*/ \};
\par \tab class D_priv : private   B \{ /*...*/ \};
\par \tab class D_prot : protected B \{ /*...*/ \};
\par \tab class D_publ : public    B \{ /*...*/ \};
\par \tab class Client \{ B b; /*...*/ \};}{\f10\fs24 
\par }
Public and protected parts of B are "private" in D_priv, and are "protected" in D_prot.  In D_publ, public parts of B are public (D_prot is-a-kind-of-a B), and protected parts of B remain protected in D_publ.  Naturally *none* of the subclasses can access
 anything that is private in B.  Class "Client" can't even access the protected parts of B (ie: it's "sealed off").
\par It is often the case that you want to make some but not all inherited member functions public in privately/protectedly derived classes.  Ex: to make member fn B::f(int,char,float) public in D_prot, you would say:
\par \tab {\f11 class D_prot : protected B \{
\par \tab   //...
\par \tab public:
\par \tab   B::f;    //note: not  B::f(int,char,float)
\par \tab \};}{\f10\fs24 
\par }There are limitations to this technique (can't distinguish overloaded names, and you can't make a feature that was "protected" in the base "public" in the derived).  Where necessary, you can get around these by a call-through fn:
\par \tab {\f11 class D_prot : protected B \{
\par \tab public:
\par \tab   short f(int i, char c, float f) \{ return B::f(i,c,f); \}
\par \tab \};}{\f10\fs24 
\par }\pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} Do_most_C___programmers_use_containment_or_private_inheritance_}${\footnote\ftnalt \pard\plain \s45 
\f8\fs20 {\cs47\super $} Do most C++ programmers use containment or private inheritance?}}Do most C++ programmers use composition or private inheritance?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Composition.
\par Normally you don't WANT to have access to the internals of too many other classes, and private inheritance gives you some of this extra power (and responsibility).  But private inheritance isn't evil; it's just more expensive to maintain, since it increas
es the probability that someone will change something that will break your code.
\par A legitimate, long-term use for private inheritance is when you want to build a class Fred that uses code in a class Wilma, and the code from class Wilma needs to invoke methods from your new class, Fred.  In this case, Fred calls non-virtuals in Wilma, a
nd Wilma calls (usually pure) virtuals in itself, which are overridden by Fred.  This would be much harder to do with composition.
\par 
\par      class Wilma \{
\par      protected:
\par        void fredCallsWilma()
\par          \{ cout << "Wilma::fredCallsWilma()\\n"; wilmaCallsFred(); \}
\par        virtual void wilmaCallsFred() = 0;
\par      \};
\par 
\par      class Fred : private Wilma \{
\par      public:
\par        void barney()
\par          \{ cout << "Fred::barney()\\n"; Wilma::fredCallsWilma(); \}
\par      protected:
\par        virtual void wilmaCallsFred()
\par          \{ cout << "Fred::wilmaCallsFred()\\n"; \}
\par      \};
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} How_do_I_separate_interface_from_implementation_in_C____like_Modula_2__}${\footnote\ftnalt \pard\plain 
\s45 \f8\fs20 {\cs47\super $} How do I separate interface from implementation in C++ (like Modula-2)?}}How do I separate interface from implementation in C++ (like Modula-2)?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Use an ABC (see next question for what an ABC is).{\f10\fs24 
\par }\pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_is_an_ABC___abstract_base_class___}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super $}
 What is an ABC (\ldblquote abstract base class')?}}What is an ABC ("abstract base class")?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 At the design level, an ABC corresponds to an abstract concept.  If you asked a
\par Mechanic if he repaired Vehicles, he'd probably wonder what KIND-OF Vehicle you had in mind.  Chances are he doesn't repair space shuttles, ocean liners, bicycles, or nuclear submarines.  The problem is that the term "Vehicle" is an abstract concept (e.g.
, you can't build a "vehicle"
\par unless you know what kind of vehicle to build).  In C++, class Vehicle would be an ABC, with Bicycle, SpaceShuttle, etc, being subclasses (an OceanLiner is-a-kind-of-a Vehicle).  In real-world OOP, ABCs show up all over the place. 
\par As programming language level, an ABC is a class that has one or more pure virtual member functions (see next FAQ).  You cannot make an object (instance) of an ABC.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_is_a__pure_virtual__member_function_}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super $}
 What is a \ldblquote pure virtual' member function?}}What is a "pure virtual" member function?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 
Some member functions exist in concept, but can't have any actual defn.  Ex: Suppose I asked you to draw a Shape at location (x,y) that has size 7.2.  You'd ask me "what kind of shape should I draw", since cir
cles, squares, hexagons, etc, are drawn differently.  In C++, we indicate the existence of the "draw()" method, but we recognize it can only be defined in subclasses:
\par \tab {\f11 class Shape \{
\par \tab public:
\par \tab   virtual void draw() const = 0;
\par \tab   //...                     ^^^--- "=0" means it is "pure virtual"
\par \tab \};}{\f10\fs24 
\par }This pure virtual makes "Shape" an ABC.  The "const" says that invoking the "draw()" method won't change the Shape object (ie: it won't move around on the screen, change sizes, etc).  If you want, you can think of i
t as if the code were at the nil pointer.
\par Pure virtuals allow you to express the idea that any actual object created from a [concrete] class derived from the ABC *will* have the indicated member fn, but we simply don't have enough information to actually *define* it yet.  They allow separation of
 interface from implementation, which ultimately allows functionally equivalent subclasses to be produced that can "compete" in a free market sense (a technical version of "market driven economics").
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} How_can_I_provide_printing_for_an_entire_hierarchy_rooted_at__class_X__}${\footnote\ftnalt \pard\plain 
\s45 \f8\fs20 {\cs47\super $} How can I provide printing for an entire hierarchy rooted at \ldblquote class X'?}}How can I provide printing for an entire hierarchy rooted at "class X"?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Provide a friend operator<< that calls a protected virtual function:
\par {\f11     class X \{
\par     protected:
\par       virtual void print(ostream& o) const;  //or "=0;" if "X" is abstract
\par     public:
\par       friend ostream& operator<<(ostream& o,const X& x) \{x.print(o); return o;\}
\par       //...
\par     \};}{\f10\fs24 
\par }Now all subclasses of X merely provide their own "print(ostream&)const" member function, and they all share the common "<<" operator.  Friends don't bind dynamically, but this technique makes them *act* as if they were.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_is_a__virtual_destructor__}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super $} What is a 
\ldblquote virtual destructor'?}}What is a "virtual destructor"?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 
In general, a virtual fn means to start at the class of the object itself, not the type of the pointer/ref ("do the right thing based on the actual class of" is a good way to remember it).  Virtual destructors
 (dtors) are no different: start the destruction process "down" at the object's actual class,
\par rather than "up" at the ptr's class (ie: "destroy yourself using the *correct* destruction routine").
\par Virtual destructors are so valuable that some people want compilers to holler at you if you forget them.  In general there's only one reason *not* to make a class' dtor virtual: if that class has no virtual fns, the introduction of the first virtual fn im
poses typically 4 bytes overhead in the size of each object (there's a bit of magic for how C++ "does the right thing", and it boils down to an extra ptr per object called the "virtual table pointer" or "vptr").
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_is_a__virtual_constructor__}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super $}
 What is a \ldblquote virtual constructor'?}}What is a "virtual constructor"?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 
Technically speaking, there is no such thing.  You can get the effect you desire by a virtual "clone()" member fn (for copy constructing), or a "fresh()" member fn (also virtual) which constructs/creates a new object of the same class but is "fresh" (like
 the "default" [zero parameter] ctor would do).
\par The reason ctors can't be virtual is simple: a ctor turns raw bits into a living object.  Until there's a living respondent to a message, you can't
\par expect a message to be handled "the right way".  You can think of ctors as "class" [static] functions, or as "factories" which churn out objects.
\par Thinking of ctors as "methods" attached to an object is misleading.
\par Here is an example of how you could use "clone()" and "fresh()" methods:
\par \tab {\f11 class Set \{  //normally this would be a template
\par \tab public:
\par \tab   virtual void insert(int);\tab //Set of "int"
\par \tab   virtual int  remove();
\par \tab   //...
\par \tab   virtual Set& clone() const = 0;\tab //pure virtual; Set is an ABC
\par \tab   virtual Set& fresh() const = 0;
\par \tab   virtual ~Set() \{ \}\tab //see on "virtual destructors" for more
\par \tab \};
\par \tab class SetHT : public Set \{
\par \tab   //a hash table in here
\par \tab public:
\par \tab   //...
\par \tab   Set& clone() const \{ return *new SetHT(*this); \}
\par \tab   Set& fresh() const \{ return *new SetHT(); \}
\par \tab \};
\par }"new SetHT(...)" returns a "SetHT*", so "*new" returns a 
SetHT&.  A SetHT is-a Set, so the return value is correct.  The invocation of "SetHT(*this)" is that of copy construction ("*this" has type "SetHT&").  Although "clone()" returns a new SetHT, the caller of clone() merely knows he has a Set, not a SetHT (w
hich is desirable in the case of wanting a "virtual ctor").  "fresh()" is similar, but it constructs an "empty" SetHT.
\par Clients can use this as if they were "virtual constructors":
\par \tab {\f11 void client_code(Set& s)
\par \tab \{
\par \tab   Set& s2 = s.clone();
\par \tab   Set& s3 = s.fresh();
\par \tab   //...
\par \tab   delete &s2;\tab //relies on destructor being virtual!!
\par \tab   delete &s3;\tab // ditto
\par \tab \}}{\f10\fs24 
\par }This fn will work correctly regardless of how the Set is implemented (hash table based, AVL tree based, etc).
\par See above on "separation of interface from implementation" for more.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_are_some_good_C___coding_standards_}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super $}
 What are some good C++ coding standards?}}What are some good C++ coding standards?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Thank you for reading this answer rather than just trying to set your own coding standards.
\par But please don't ask 
this question on comp.lang.c++.  Nearly every software engineer has, at some point, felt that coding standards are or can be used as a "power play."  Furthermore some attempts to set C++ coding standards have been made by those unfamiliar with the languag
e and/or paradigm, so the standards end up being based on what WAS the state-of-the-art when the standards setters where writing code.  Such impositions generate an attitude of mistrust for coding standards.
\par Obviously anyone who asks this question on comp.lang.c++ wants to be trained so they DON'T run off on their own ignorance, but nonetheless the answers tend to generate more heat than light.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} Are_coding_standards_necessary___sufficient_}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super 
$} Are coding standards necessary?  sufficient?}}Are coding standards necessary?  sufficient?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 
Coding standards do not make non OO programmers into OO programmers; only training and experience do that.  If coding standards have merit, it is that they discourage the petty fragmentation that occurs when large organizations c
oordinate the activities of diverse groups of programmers. 
\par But you really want more than a coding standard.  The structure provided by coding standards gives neophytes one less degree of freedom to worry about, however pragmatics go well beyond pretty-printing standards.  Organizations need a consistent PHILOSOPH
Y of design and implementation.  E.g., strong or weak typing?  references or ptrs in interfaces?  stream I/O or stdio?  should C++ code call our C?  vise versa?  how should ABCs be used?  should in
heritance be used as an implementation technique or as a specification technique?  what testing strategy should be employed?  inspection strategy?  should interfaces uniformly have a "get" and/or "set" method for each data member?  should interfaces be de
signed from the outside-in or the inside-out?  should errors be handled by try/catch/throw or return codes?  etc.
\par What is needed is a "pseudo standard" for detailed DESIGN.  I recommend a three-pronged approach to achieving this standardization: training, m
entoring, and libraries.  Training provides "intense instruction," mentoring allows OO to be caught rather than just taught, and a high quality C++ class library provides "long term instruction."  There is a thriving commercial market for all three kinds 
of "training."  Advice by organizations who have been through the mill is consistent: Buy, Don't Build.  Buy libraries, buy training, buy tools, buy consulting.  Companies who have attempted to become a self-taught tool-shop as well as an application/syst
em shop have found success difficult.
\par Few argue that coding standards are "ideal," or even "good," however they are necessary in the kind of organizations/situations described above.
\par The following FAQs provide some basic guidance in conventions and styles.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} Should_our_organization_determine_coding_standards_from_our_C_experience_}${\footnote\ftnalt 
\pard\plain \s45 \f8\fs20 {\cs47\super $} Should our organization determine coding standards from our C experience?}}Should our organization determine coding standards from our C experience?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 No!
\par No matter how vast your 
C experience, no matter how advanced your C expertise, being a good C programmer does not make you a good C++ programmer.  Converting from C to C++ is more than just learning the syntax and semantics of the "++" part of C++.  Organizations who want the pr
omise of OOP, but who fail to put the "OO" into OOP, are fooling themselves; the balance sheet will show their folly.
\par C++ coding standards should be tempered by C++ experts.  Asking comp.lang.c++ is a start (but don't use the term "coding standard" in the question; instead simply say, "what are the pros and cons of this technique?").  Seek out experts who can help guide 
you away from pitfalls.  Get training.  Buy libraries and see if "good" libraries pass your coding standards.  Do NOT set standards by yourself unless you have considerable experience in C++.  Having no standard is better than having a bad standard, since
 improper "official" positions "harden" bad brain traces.  There is a thriving market for both C++ training and libraries from which to pool expertise.
\par One more thing: whenever something is in demand, the potential for charlatans increases.  Look before you leap.  Also ask for student-reviews from past companies, since not even expertise makes someone a good communicator. Finally, select a practitioner w
ho can teach, not a full time teacher who has a passing knowledge of the language/paradigm.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} Should_I_declare_locals_in_the_middle_of_a_fn_or_at_the_top_}${\footnote\ftnalt \pard\plain \s45 
\f8\fs20 {\cs47\super $} Should I declare locals in the middle of a fn or at the top?}}Should I declare locals in the middle of a fn or at the top?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Declare near first use.
\par An object is initialized (constructed) the moment it is declared.  If you don't have enough information to initialize an object until half way down the fn, you can either initialize it to an "empty" value at the top then "assign" it later, or initialize i
t correctly half way down the fn.  It's cheaper (in runtim
e performance) to get it right the first time than to build it once, tear it down, and build it again.  Simple examples show a factor of 350% speed hit for simple classes like "String".  Your mileage may vary; surely the overall system degradation will be
 less that 300+%, but there WILL be degradation. UNNECESSARY degradation.
\par A common retort to the above is: "we"ll provide "set" methods for every datum in our objects, so the cost of construction will be spread out." This is worse than the performance overh
ead, since now you're introducing a maintenance nightmare.  Providing "set" methods for every datum is tantamount to public data: you've exposed your implementation technique to the world.  The only thing you've hidden is the physical NAMES of your member
 objects, but the fact that you're using a List and a String and a float (for example) is open for all to see.  Maintenance generally consumes far more resources than run-time CPU.
\par Locals should be declared near their first use.  Sorry that this isn't familiar to C experts, but "new" doesn't necessarily mean "bad."
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 \page {\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_source_file_name_convention_is_best___foo_C____foo_cc____foo_cpp__}${\footnote\ftnalt \pard\plain \s45 
\f8\fs20 {\cs47\super $} What source-file-name convention is best? \ldblquote foo.C'? \ldblquote foo.cc'? \ldblquote foo.cpp'?}}What source-file-name convention is best? "foo.C"? "foo.cc"? "foo.cpp"?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 If you already have a convention, use it.  If not, consult your compiler to see what the compiler expects.  Typical a
nswers are: ".C", ".cc", ".cpp", or ".cxx" (naturally the ".C" extension assumes a case-sensitive file system to distinguish ".C" from ".c").
\par At Paradigm Shift, Inc., we use ".C" in our Makefiles even on case-insensitive file systems (on case-insensitive file systems, we supply the compiler option that means "assume all .c files are C++ source files"; e.g., "-Tdp" for IBM CSet++, "-cpp" for Zor
tech C++, "-P" for Borland C++, etc).
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_header_file_name_convention_is_best___foo_H____foo_hh____foo_hpp__}${\footnote\ftnalt \pard\plain 
\s45 \f8\fs20 {\cs47\super $} What header-file-name convention is best? \ldblquote foo.H'? \ldblquote foo.hh'? \ldblquote foo.hpp'?}}What header-file-name convention is best? "foo.H"? "foo.hh"? "foo.hpp"?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 
The naming of your source files is cheap since it doesn't effect your source code.  Your substantial investment is your source code.  Therefore the names of your header files must be chosen with much greater care.  The preprocessor will accept whatever na
me you give it in the #include line, but whatever you choose, you will want to plan on sticking with it for a long time, since it is more expensive to change (though certainly not as difficult as, say, porting to a new language).{\f10\fs24 
\par }Almost all vendors ship their C++ header files using a ".h" extension, which
\par means you can reliably do things like:
\par \tab \tab {\f11 #include <iostream.h>}{\f10\fs24 
\par }Well, *almost*.  There are one or two vendors that provide <iostream.hpp>.  A few #ifdef"s, suffice.  There are also tools that recognize the language of a file by its extension rather than its contents (gnu emacs looks in the first few lines for a stri
ng magic token in a comment identifying the language). Some of these extension-based tools use ".hh" or ".H" to identify C++ headers, however most of the world is leaning toward ".h" for C++ headers.  C++ specific information in a ".h" that is to be share
d with a C compiler can be #ifdef'd sing:{\f10\fs24 
\par }\tab {\f11 #ifdef __cplusplus /*all C++ compilers define _cplusplus*/
\par \tab \tab   // ... C++ specific stuff here ...
\par \tab #endif}{\f10\fs24 
\par }\pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} Are_there_any_lint_like_guidelines_for_C___}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super 
$} Are there any lint-like guidelines for C++?}}Are there any lint-like guidelines for C++?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Yes, there are some practices which are generally considered dangerous. However none of these are universally "bad," since situations arise when even the worst of these is needed:
\par \tab * a class "Fred"s assignment operator should return "*this" as an "Fred&" (allows chaining of assignments)
\par  \tab * a class with any virtual fns ought to have a virtual destructor
\par  \tab * a class with any of \{destructor, assignment operator, copy constructor\} generally needs all 3
\par  \tab * a class "Fred"s copy constructor and assignment operator should have "const" in the parameter: respectively "Fred::Fred(const Fred&)" and "Fred& Fred::operator=(const Fred&)".
\par  \tab * always use initialization lists for class sub-objects rather than assignment the performance difference for user-defined classes can be substantial (3x!)
\par  \tab * many assignment operators should start by testing if "we" are "them"; e.g.,
\par 
\par      Fred& Fred::operator= (const Fred& fred)
\par      \{
\par        if (this == &fred) return *this;
\par        //...normal assignment duties...
\par        return *this;
\par      \}
\par sometimes there is no need to check, but these situations generally correspond to when there's no need for an explicit user-specified assignment op (as opposed to a compiler-synthesized assignment-op).
\par  \tab 
* in classes that define both "+=," "+" and "=," "a+=b" and "a=a+b" should generally do the same thing; ditto for the other identities of builtin types (e.g., a+=1 and ++a; p[i] and *(p+i); etc).  This can be enforced by writing the binary ops using the
 "op=" forms; e.g.,
\par      Fred operator+ (const Fred& a, const Fred& b)
\par      \{
\par        Fred ans = a;
\par        ans += b;
\par        return ans;
\par      \}
\par This way the "constructive" binary ops don't even need to be friends. But it is sometimes possible to more efficiently implement common ops (e.g.,if class "Fred" is actually "String," and "+=" has to reallocate/copy string memory, it may be better to know
 the eventual length from the beginning).
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} Why_does_C___s_FAQ_have_a_section_on_Smalltalk__Is_this_Smalltalk_bashing_}${\footnote\ftnalt 
\pard\plain \s45 \f8\fs20 {\cs47\super $} Why does C++'s FAQ have a section on Smalltalk? Is this Smalltalk-bashing?}}Why does C++'s FAQ have a section on Smalltalk? Is this Smalltalk-bashing?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 
The two "major" OOPLs in the world are C++ and Smalltalk.  Due to its popularity as the OOPL with the second largest user pool, many new C++ programmers come from a Smalltalk background.  This section answers the questions:
\par  \tab * what's different about the two languages
\par  \tab * what must a Smalltalk-turned-C++ programmer know to master C++
\par This section does *!*NOT*!* attempt to answer the questions:
\par  \tab * which language is "better"?
\par  \tab * why is Smalltalk "bad"?
\par  \tab * why is C++ "bad"?
\par Nor is it an open invitation for some Smalltalk terrorist to slash my tires while I sleep (on those rare occasions when I have time to rest these days :-).
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_s_the_difference_between_C___and_Smalltalk_}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {
\cs47\super $} What's the difference between C++ and Smalltalk?}}What's the difference between C++ and Smalltalk?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 The most important differences are:
\par  \tab * static typing vs dynamic typing?
\par  \tab * must inheritance be used for subtyping only?
\par  \tab * value vs reference semantics?
\par The first two differences are illuminated in the remainder of this section; the third point is the subject of the section that follows.
\par If you're a Smalltalk programmer who wants to learn C++, you'd be very wise to study the next three FAQs carefully.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_is__static_typing___and_how_is_it_similar_dissimilar_to_Smalltalk_}${\footnote\ftnalt \pard\plain 
\s45 \f8\fs20 {\cs47\super $} What is \ldblquote static typing', and how is it similar/dissimilar to Smalltalk?}}What is "static typing", and how is it similar/dissimilar to Smalltalk?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 
Static typing says the compiler checks the type-safety of every operation STATICALLY (at compile-time), rather than to generate code which will check things at run-time.  For example, with static typing, the signature matching of fn arguments is checked, 
and an improper match is flagged as an error by the COMPILER, not at run-time.
\par In OO code, the most common "typing mismatch" is invoking a member function against an object which isn't prepared to handle the operation. E.
g., if class "Fred" has member fn "f()" but not "g()", and "fred" is an instance of class "Fred", then "fred.f()" is legal and "fred.g()" is illegal.  C++ (statically typed) catches the error at compile time, and Smalltalk (dynamically typed) catches the 
error at run-time.  (Technically speaking, C++ is like Pascal--PSEUDO statically typed-- since ptr casts and unions can be used to violate the typing system; which reminds me: only use ptr casts and unions as often as you use "goto"s).
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 \page {\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} Which_is_a_better_fit_for_C_____static_typing__or__dynamic_typing__}${\footnote\ftnalt \pard\plain \s45 
\f8\fs20 {\cs47\super $} Which is a better fit for C++: \ldblquote static typing' or \ldblquote dynamic typing'?}}Which is a better fit for C++: "static typing" or "dynamic typing"?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 If you want to use C++ most effectively, use it as a statically typed language.
\par C++ is flexible enough that you can (via ptr casts, unions, and #defines) make it "look" like Smalltalk.  But don't.  Which reminds me: try to avoid #define.
\par There are places where ptr casts and unions are necessary and even wholesome, but th
ey should be used carefully and sparingly.  A ptr cast tells the compiler to believe you.  An incorrect ptr cast might corrupt your heap, scribble into memory owned by other objects, call nonexistent ethods, and cause general failures.  It's not a pretty 
sight.  If you avoid these and related constructs, you can make your C++ code both safer and faster, since anything that can be checked at compile time is something that doesn't have to be done at run-time.
\par Even if you're in love with dynamic typing, please
 avoid it in C++, or else please consider using another language that better supports your desire to defer typing decisions to run-time.  C++ performs 100% of its type checking at compile time; it has NO built-in mechanism to do ANY type checking at run-t
ime. If you use C++ as a dynamically typed OOPL, your life is in your own ands.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} How_can_you_tell_if_you_have_a_dynamically_typed_C___class_library_}${\footnote\ftnalt \pard\plain 
\s45 \f8\fs20 {\cs47\super $} How can you tell if you have a dynamically typed C++ class library?}}How can you tell if you have a dynamically typed C++ class library?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Hint #1: when everything is derived from a single root class, usually "Object."
\par Hint #2: when the container classes (List, Stack, Set, etc) are non-templates.
\par Hint #3: when the container classes (List, Stack, Set, etc) insert/extract elements as pointers to "Object" (you can put an Apple into such a container, but when you get it out, the compiler knows only that it is derived from Object, so you have to use a 
pointer cast to convert it back to an Apple*; and you better pray a lot that it really IS an Apple, cause your blood is on your own head).
\par You can make the pointer cast "safe" by using "dynamic_cast" (see earlier), but this dynamic testing is just that: dynamic.  This coding style is the essence of dynamic typing in C++.  You call a function that says "convert this Object into an Apple or gi
ve me NULL if its not an Apple," and you've got dynamic typing: you don't know what will happen until run-time.
\par When you use with templates 
to implement your containers, the C++ compiler can statically validate 99% of an application's typing information (the figure "99%" is apocryphal; some claim they always get 100%, those who need persistence get something less than 100% static type checkin
g). The point is:C++ gets genericity from templates, not from inheritance.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} Will__standard_C____include_any_dynamic_typing_primitives_}${\footnote\ftnalt \pard\plain \s45 
\f8\fs20 {\cs47\super $} Will \ldblquote standard C++' include any dynamic typing primitives?}}Will "standard C++" include any dynamic typing primitives?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 
The ANSI/ISO C++ standardization committees are considering proposals to add type-safe pointer casts and other run-time type mechanisms into the C++ standard.  When this happens, it will be easier to do run-time typing in those cases where it truly is nee
ded (ex: for persistence), but hopefully the new syntax won't encourage abuses where if-then-else'ing the run-time type is used to replace a virtual function call.
\par Note that the effect of a down-cast and a virtual fn call are similar: in the member fn tha
t results from the virtual fn call, the "this" ptr is a downcasted version of what it used to be (it went from ptr-to-Base to ptr-to-Derived). The difference is that the virtual fn call *always* works: it never makes the wrong "down-cast" and it automatic
ally extends itself whenever a new subclass is created -- as if an extra "case" or "if/else" magically appearing in the weak typing technique.  The other difference is that the client gives control to the object rather than reasoning *about* the object.

\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_is_value_and_or_reference_semantics__and_which_is_best_in_C___}${\footnote\ftnalt \pard\plain 
\s45 \f8\fs20 {\cs47\super $} What is value and/or reference semantics, and which is best in C++?}}What is value and/or reference semantics, and which is best in C++?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 
With reference semantics, assignment is a pointer-copy (i.e., a REFERENCE). Value (or "copy") semantics mean assignment copies the value, not just the pointer.  C++ gives you the choice: use the assignment operator to copy the value (copy/value semantics)
, or use a ptr-copy to copy a pointer (reference semantics).  C++ allows you to override the assignment operator to do anything your heart desires, however the default (and most common) choice is to copy the VALUE.
\par Pros of reference semantics: flexibility and dynamic binding (you get dynamic binding in C++ only when you pass by ptr or pass by ref, not when you pass by value).
\par Pros of value semantics: speed.  "Speed" seems like an odd benefit to for a feature that requires an object (vs a ptr) to be copied, but the fact of the matter is that one usually ac
cesses an object more than one copies the object, so the cost of the occasional copies is (usually) more than offset by the benefit of having an actual object rather than a ptr to an object.
\par There are three cases when you have an actual object as opposed to a pointer to an object: local vars, global/static vars, and fully contained member objects in a class.  The most important of these is the last ("composition").
\par More info about copy-vs-reference semantics is given in the next FAQs. Please read them all t
o get a balanced perspective.  The first few have intentionally been slanted toward value semantics, so if you only read the first few of the following FAQs, you'll get a warped perspective.
\par Assignment has other issues (e.g., shallow vs deep copy) which are not covered here.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_is__virtual_data___and_how_can___why_would_I_use_it_in_C___}${\footnote\ftnalt \pard\plain \s45 
\f8\fs20 {\cs47\super $} What is \ldblquote virtual data', and how-can / why-would I use it in C++?}}What is "virtual data", and how-can / why-would I use it in C++?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Virtual data allows a derived clas
s to change the exact class of a base class's member object.  Virtual data isn't strictly "supported" by C++, however it can be simulated in C++.  It ain't pretty, but it works.
\par To simulate virtual data in C++, the base class must have a pointer to the member object, and the derived class must provide a "new" object to be pointed to by the base class's pointer.  The base class would also have one or more normal constructors that 
provide their own referrent (again via "new"), and the base class's destructor would "delete" the referent.
\par For example, class "Stack" might have an Array member object (using a pointer), and derived class "StretchableStack" might override the base class member data from "Array" to "StretchableArray".  For this to work, StretchableArray would have to inherit fr
om Array, so Stack would have an "Array*".  Stack's normal constructors would initialize this "Array*" with a "new Array", but Stack would also have a (possibly "protected:") constructor that would accept an "Array*" from a deri
ved class. StretchableArray's constructor would provide a "new StretchableArray" to this special constructor.
\par {\b Pros:}
\par  \tab * Easier implementation of StretchableStack (most of the code is inherited).
\par  \tab * Users can pass a StretchableStack as a kind-of Stack.
\par {\b Cons:}
\par  \tab * Adds an extra layer of indirection to access the Array.
\par  \tab * Adds some extra freestore allocation overhead (both new and delete).
\par  \tab * Adds some extra dynamic binding overhead (reason given in next FAQ).
\par In other words, we succeeded at making OUR job easier as the implementor of StretchableStack, but all our users pay for it.  Unfortunately the extra overhead was imposed on both users of StretchableStack AND on users of Stack.
\par See the FAQ after the next to find out how much the users "pay."  Also: PLEASE read the few FAQs that follow the next one too (YOU WILL NOT GET A BALANCED PERSPECTIVE WITHOUT THE OTHERS).
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 \page {\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_s_the_difference_between_virtual_data_and_dynamic_data_}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {
\cs47\super $} What's the difference between virtual data and dynamic data?}}What's the difference between virtual data and dynamic data?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 The easiest way to see the distinction is by an analogy with "virtual fns":
\par A virtual member fn means the declaration (signature) must stay the same in subclasses, but the defn (body) can be overridden.  The overriddenness of an inherited member fn is a static property of the subclass; it doesn't change dynamically throughout the
 life of any particular object, nor is it possible for distinct objects of the subclass to have distinct defns of the member fn.
\par Now go back and re-read the previous paragraph, but make these substitutions:
\par  \tab * "member fn" \tab --> "member object"
\par  \tab * "signature" \tab --> "type"
\par  \tab * "body"      \tab --> "exact class"
\par After this, you'll have a working definition of virtual data.
\par Another way to look at this is to distinguish "per-object" member functions from "dynamic" member functions.  A "per-object" member fn is a member fn that is potentially different in any given instance of an object, and could be implemented by burying a f
unction ptr in the obje
ct; this pointer could be "const", since the pointer will never be changed throughout the object's life. A "dynamic" member fn is a member fn that will change dynamically over time; this could also be implemented by a function ptr, but the fn ptr would no
t be const.
\par Extending the analogy, this gives us three distinct concepts for data members:
\par  \tab * virtual data: the defn ("class") of the member object is overridable in subclasses provided its declaration ("type") remains the same, and this overriddenness is a static property of the subclass.
\par  \tab 
* per-object-data: any given object of a class can instantiate a different conformal (same type) member object upon initialization (usually a "wrapper" object), and the exact class of the member object is a static property of the object that wraps it.

\par  \tab * dynamic-data: the member object's exact class can change dynamically over time.
\par The reason they all look so much the same is that none of this is "supported" in C++.  It's all merely "allowed," and in this case, the mechanism for faking each of these is the same: a ptr to a (probably abstract) base class.  In a language that made the
se "first class" abstraction mechanisms, the difference would be more striking, since they'd each have a different syntactic variant.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} Should_class_subobjects_be_ptrs_to_freestore_allocated_objs__or_contained_}${\footnote\ftnalt 
\pard\plain \s45 \f8\fs20 {\cs47\super $} Should class subobjects be ptrs to freestore allocated objs, or contained?}}Should class subobjects be ptrs to freestore allocated objs, or should I use "composition"?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Composition.
\par Your member objects should normally be "contained" in the composite object (but not always; "wrapper" objects are a good example of where you want a ptr/ref; also the N-to-1-uses-a relationship needs something like a ptr/ref).
\par There are three reasons why fully contained member objects ("composition") has better performance than ptrs to freestore-allocated member objects:
\par  \tab * Extra layer to indirection every time you need to access the member object.
\par  \tab * Extra freestore allocations ("new" in constructor, "delete" in destructor).
\par  \tab * Extra dynamic binding (reason given below).
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_are_relative_costs_of_the_3_performance_hits_of_allocated_subobjects_}${\footnote\ftnalt 
\pard\plain \s45 \f8\fs20 {\cs47\super $} What are relative costs of the 3 performance hits of allocated subobjects?}}What are relative costs of the 3 performance hits of allocated subobjects?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 The three performance hits are enumerated in the previous FAQ:
\par  \tab * By itself, an extra layer of indirection is small potatoes.
\par  \tab * Freestore allocations can be a performance issue (the performance of the
\par typical implementation of malloc degrades when there are many allocations; OO s/w can easily become "freestore bound" unless you're careful).
\par  \tab * The extra dynamic binding comes from having a ptr rather than an object. Whenever the C++ compiler can know an object's EXACT class, virtual fn calls can be STATICALLY bound, which allows inlining.  Inlining allows zillions (would yo
u believe half a dozen :-) optimization opportunities such as procedural integration, register lifetime issues, etc.  The C++ compiler can know an object's exact class in three circumstances:
\par \tab local variables, global/static variables, and fully-contained member objects.
\par Thus fully-contained member objects allow significant optimizations that wouldn't be possible under the "member objects-by-ptr" approach.  This is the main reason that languages which enforce reference-semantics have "inherent" performance challenges.

\par {\b NOTE:} PLEASE READ THE NEXT THREE FAQs TO GET A BALANCED PERSPECTIVE!
\par 
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_is_an__inline_virtual_member_fn____Are_they_ever_actually__inlined__}${\footnote\ftnalt 
\pard\plain \s45 \f8\fs20 {\cs47\super $} What is an \ldblquote inline virtual member fn'?  Are they ever actually \ldblquote inlined'?}}What is an "inline virtual member fn"?  Are they ever actually "inlined"?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Yes but...
\par A virtual call via a ptr or ref is always resolved dynamically, which can never be inlined.  Reason: the compiler can't know which actual code to call until run-time (i.e., dynamically), sinc
e the code may be from a derived class that was created after the caller was compiled.
\par Therefore the only time an inline virtual call can be inlined is when the compiler knows the "exact class" of the object which is the target of the virtual function call.  This can happen only when the compiler has an actual object rather than a pointer o
r reference to an object.  I.e., either with a local object, a global/static object, or a fully contained object inside a composite.
\par Note that the difference between inli
ning and non-inlining is normally MUCH more significant than the difference between a regular fn call and a virtual fn call.  For example, the difference between a regular fn call and a virtual fn call is often just two extra memory references, but the di
fference between an inline function and a non-inline function can be as much as an order of magnitude (for zillions of calls to insignificant member fns, loss of inlining virtual fns can result in 25X speed degradation!  [Doug Lea, "Customization in C++,"
 proc Usenix C++ 1990]).
\par A practical consequence of this insight: don't get bogged down in the endless debates (or sales tactics!) of compiler/language vendors who compare the cost of a virtual function call on their language/compiler with the same on another language/compiler.  
Such comparisons are largely meaningless when compared with the ability of the language/compiler to "inline expand" member function calls. I.e., many language implementation vendors make a big stink about how good their dispatch strat
egy is, but if these implementations don't INLINE method calls, the overall system performance would be poor, since it is inlining --NOT dispatching-- that has the greatest performance impact.
\par {\b NOTE:} PLEASE READ THE NEXT TWO FAQs TO SEE THE OTHER SIDE OF THIS COIN!
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} Sounds_like_I_should_never_use_reference_semantics__right_}${\footnote\ftnalt \pard\plain \s45 
\f8\fs20 {\cs47\super $} Sounds like I should never use reference semantics, right?}}Sounds like I should never use reference semantics, right?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Wrong.
\par Reference semantics are A Good Thing.  We can't live wit
hout pointers. We just don't want our s/w to be One Gigantic Rats Nest Of Pointers.  In C++, you can pick and choose where you want reference semantics (ptrs/refs) and where you'd like value semantics (where objects physically contain other objects etc). 
 In a large system, there should be a balance.  However if you implement absolutely EVERYTHING as a pointer, you'll get enormous speed hits.
\par Objects near the problem skin are larger than higher level objects.  The IDENTITY of these "problem space" abstractions is usually more important than their "value."  Thus reference semantics should be used for problem-space objects.
\par Note that these problem space objects are normally at a higher level of abstraction than the solution space objects, so the problem space objects normally have a relatively lower frequency of interaction.  Therefore C++ gives us an IDEAL situation: we cho
ose reference semantics for objects that need unique identity or that are too large to copy, and we can choose value semantics for the othe
rs.  Thus the highest frequency objects will end up with value semantics, since we install flexibility where it doesn't hurt us (only), and we install performance where we need it most!
\par These are some of the many issues the come into play with real OO design. OO/C++ mastery takes time and high quality training.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} Does_the_poor_performance_of_ref_semantics_mean_I_should_pass_by_value_}${\footnote\ftnalt \pard\plain 
\s45 \f8\fs20 {\cs47\super $} Does the poor performance of ref semantics mean I should pass-by-value?}}Does the poor performance of ref semantics mean I should pass-by-value?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 No.  In fact, "NO!" :-)
\par The previous questions were talking about *subobjects*, not parameters.  Pass-by-value is usually a bad idea when mixed with inheritance (larger subclass objects get "sliced' when passed by value as a base class object).  Generally, objects that are part 
of an inheritance hierarchy should be passed by ref or by ptr, but not by value, since only then do you get the (desired) dynamic binding.
\par Unless compelling reasons are given to the contrary, subobjects should be by value and parameters should be by reference.  The discussion in the previous few questions indicates some of the "compelling reasons" for when subobjects should be by reference.{
\f10\fs24 
\par }\pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 \page {\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} How_can_I_call_a_C_function__f____from_C___code_}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super $}
 How can I call a C function \ldblquote f()' from C++ code?}}How can I call a C function "f(int,char,float)" from C++ code?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Tell the C++ compiler that it is a C function:
\par      extern "C" void f(int,char,float);
\par Be sure to include the full function prototype.  A block of many C functions can be grouped via braces, as in:
\par      extern "C" \{
\par        void* malloc(size_t);
\par        char* strcpy(char* dest, const char* src);
\par        int   printf(const char* fmt, ...);
\par      \}
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} How_can_I_create_a_C___function__f____that_is_callable_by_my_C_code_}${\footnote\ftnalt \pard\plain 
\s45 \f8\fs20 {\cs47\super $} How can I create a C++ function \ldblquote f()' that is callable by my C code?}}How can I create a C++ function "f()" that is callable by my C code?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 The C++ compiler must know that "f(int,c
har,float)" is to be called by a C compiler using the same "extern C" construct detailed in the previous FAQ. Then you define the function in your C++ module:
\par      void f(int x, char y, float z)
\par      \{
\par        //...
\par      \}
\par The "extern C" line tells the compiler that the external information sent to the linker should use C calling conventions and name mangling (e.g., preceded by a single underscore).  Since name overloading isn't supported by C, you can't make several overlo
aded fns simultaneously callable by a C program.
\par Caveats and implementation dependencies:
\par  \tab * your "main()" should be compiled with your C++ compiler (for static init).
\par  \tab * your C++ compiler should direct the linking process (for special libraries).
\par  \tab * your C and C++ compilers may need to come from same vendor and have compatible versions (i.e., needs same calling convention, etc.).
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} Why_s_the_linker_giving_errors_for_C_C___fns_being_called_from_C___C_fns_}${\footnote\ftnalt 
\pard\plain \s45 \f8\fs20 {\cs47\super $} Why's the linker giving errors for C/C++ fns being called from C++/C fns?}}Why's the linker giving errors for C/C++ fns being called from C++/C fns?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 See the previous two FAQs on how to use "extern "C"."
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} How_can_I_pass_an_object_of_a_C___class_to_from_a_C_function_}${\footnote\ftnalt \pard\plain \s45 
\f8\fs20 {\cs47\super $} How can I pass an object of a C++ class to/from a C function?}}How can I pass an object of a C++ class to/from a C function?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Here's an example:
\par 
\par      /****** C/C++ header file: Fred.h ******/
\par      #ifdef __cplusplus    /*"__cplusplus" is #defined if/only-if compiler is C++*/
\par        extern "C" \{
\par      #endif
\par 
\par      #ifdef __STDC__
\par        extern void c_fn(struct Fred*);  /* ANSI-C prototypes */
\par        extern struct Fred* cplusplus_callback_fn(struct Fred*);
\par      #else
\par        extern void c_fn();              /* K&R style */
\par        extern struct Fred* cplusplus_callback_fn();
\par      #endif
\par 
\par      #ifdef __cplusplus
\par        \}
\par      #endif
\par 
\par      #ifdef __cplusplus
\par        class Fred \{
\par        public:
\par          Fred();
\par          void wilma(int);
\par        private:
\par          int a_;
\par        \};
\par      #endif
\par 
\par "Fred.C" would be a C++ module:
\par 
\par      #include "Fred.h"
\par      Fred::Fred() : a_(0) \{ \}
\par      void Fred::wilma(int a) : a_(a) \{ \}
\par 
\par      Fred* cplusplus_callback_fn(Fred* fred)
\par      \{
\par        fred->wilma(123);
\par        return fred;
\par      \}
\par "main.C" would be a C++ module:
\par      #include "Fred.h"
\par      int main()
\par      \{
\par        Fred fred;
\par        c_fn(&fred);
\par        return 0;
\par      \}
\par "c-fn.c" would be a C module:
\par      #include "Fred.h"
\par      void c_fn(struct Fred* fred)
\par      \{
\par        cplusplus_callback_fn(fred);
\par      \}
\par Passing ptrs to C++ objects to/from 
C fns will FAIL if you pass and get back something that isn't EXACTLY the same pointer.  For example, DON'T pass a base class ptr and receive back a derived class ptr, since your C compiler won't understand the pointer conversions necessary to handle mult
iple and/or virtual inheritance.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} Can_my_C_function_access_data_in_an_object_of_a_C___class_}${\footnote\ftnalt \pard\plain \s45 
\f8\fs20 {\cs47\super $} Can my C function access data in an object of a C++ class?}}Can my C function access data in an object of a C++ class?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Sometimes.
\par (First read the previous FAQ on passing C++ objects to/from C functions.)
\par You can safely access a C++ object's data from a C function if the C++ class:
\par  \tab * has no virtual functions (including inherited virtual fns)
\par  \tab * has all its data in the same access-level section (private/protected/public)
\par  \tab * has no fully-contained subobjects with virtual fns
\par If the C++ class has any base classes at all (or if any fully contained subobjects have base classes), accessing the data will TECHNICALLY be non-portable, since
 class layout under inheritance isn't imposed by the language.  However in practice, all C++ compilers do it the same way: the base class object appears first (in left-to-right order in the event of multiple inheritance), and subobjects follow.
\par Furthermore, if the class (or any base class) contains any virtual functions, you can often (but less than always) assume a "void*" appears in the object either at the location of the first virtual function or as the first word in the object.  Again, this
 is not required by the language, but it is the way "everyone" does it.
\par If the class has any virtual base classes, it is even more complicated and less portable.  One common implementation technique is for objects to contain an object of the virtual base class (V) last (regardless of where "V" shows up as a virtual base class
 in the inheritance hierarchy).  The rest of the object's parts appear in the normal order.  Every derived class that has V as a virtual base class actually has a POINTER to the V part of the final object.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 \page {\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} Why_do_I_feel_like_I_m__further_from_the_machine__in_C___as_opposed_to_C_}${\footnote\ftnalt \pard\plain \s45 
\f8\fs20 {\cs47\super $} Why do I feel like I'm \ldblquote further from the machine' in C++ as opposed to C?}}Why do I feel like I'm "further from the machine" in C++ as opposed to C?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Because you are.
\par As an OOPL, C++ allows you to model the problem domain itself, which allows you to program in the language of the problem domain rather than in the language of the solution domain.
\par One of C's great strengths is the fact that it has "no hidden mechanism": wh
at you see is what you get.  You can read a C program and "see" every clock cycle. This is not the case in C++; old line C programmers (such as many of us once were) are often ambivalent (can anyone say, "hostile") about this feature, but they soon realiz
e that it provides a level of abstraction and economy of expression which lowers maintenance costs without destroying run-time performance.
\par Naturally you can write bad code in any language; C++ doesn't guarantee any particular level of quality, reusability,
 abstraction, or any other measure of "goodness."  C++ doesn't try to make it impossible for bad programmers to write bad programs; it enables reasonable developers to create superior software.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_is_the_type_of__ptr_to_member_fn____Is_it_diffn_t_from__ptr_to_fn__}${\footnote\ftnalt 
\pard\plain \s45 \f8\fs20 {\cs47\super $} What is the type of \ldblquote ptr-to-member-fn'?  Is it diffn't from \ldblquote ptr-to-fn'?}}What is the type of "ptr-to-member-fn"?  Is it diffn't from "ptr-to-fn"?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 A member fn of class X has type:  Returntype (X::*)(Argtypes)  while a plain function has type:  Returntype (*)   (Argtypes){\f10\fs24 
\par }\pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} How_can_I_ensure__X_s_objects_are_only_created_with_new__not_on_the_stack_}${\footnote\ftnalt 
\pard\plain \s45 \f8\fs20 {\cs47\super $} How can I ensure \ldblquote X's objects are only created with new, not on the stack?}}How can I ensure "X"s objects are only created with new, not on the stack?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 
Make sure the class's constructors are "private:", and define "friend" or "static" fns that return a ptr to the objects created via "new" (make the constructors "protected:" if you want to allow derived classes). 
\par class Fred \{   //only want to allow dynamicly allocated Fred's
\par      public:
\par        static Fred* create()                 \{ return new Fred();     \}
\par        static Fred* create(int i)            \{ return new Fred(i);    \}
\par        static Fred* create(const Fred& fred) \{ return new Fred(fred);
\par \}
\par      private:
\par        Fred();
\par        Fred(int i);
\par        Fred(const Fred& fred);
\par        virtual ~Fred();
\par      \};
\par 
\par      main()
\par      \{
\par        Fred* p = Fred::create(5);
\par        ...
\par        delete p;
\par      \}
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} How_do_I_pass_a_ptr_to_member_fn_to_a_signal_handler_X_event_callback_etc_}${\footnote\ftnalt 
\pard\plain \s45 \f8\fs20 {\cs47\super $} How do I pass a ptr to member fn to a signal handler,X event callback,etc?}}How do I pass a ptr to member fn to a signal handler,X event callback,etc?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Don't.
\par Because a member function is meaningless without an object to invoke it on, you can't do this directly (if The X Windows System was rewritten in C++, it would probably pass references to OBJECTS around, not just pointers to fns; naturally the objects woul
d embody the required function and probably a whole lot more).
\par As a patch for existing software, use a top-level (non-member) function as a wrapper which takes an object obtained through some other technique (held in a global, perhaps).  The top-level function would apply the desired member function against the globa
l object.
\par E.g., suppose you want to call Fred::memfn() on interrupt:
\par      class Fred \{
\par      public:
\par        void memfn();
\par        static void staticmemfn();  //a static member fn can handle it
\par        //...
\par      \};
\par 
\par      //wrapper fn remembers the object on which to invoke memfn in a global:
\par      Fred* object_which_will_handle_signal;
\par      void Fred_memfn_wrapper() \{
\par object_which_will_handle_signal->memfn(); \}
\par 
\par      main()
\par      \{
\par        /* signal(SIGINT, Fred::memfn); */   //Can NOT do this
\par        signal(SIGINT, Fred_memfn_wrapper);  //Ok
\par        signal(SIGINT, Fred::staticmemfn);   //Also Ok
\par      \}
\par {\b Note:} static member functions do not require an actual object to be invoked, so ptrs-to-static-member-fns are type compatible with regular ptrs-to-fns (see ARM p.25, 158).
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} Why_am_I_having_trouble_taking_the_address_of_a_C___function_}${\footnote\ftnalt \pard\plain \s45 
\f8\fs20 {\cs47\super $} Why am I having trouble taking the address of a C++ function?}}Why am I having trouble taking the address of a C++ function?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 This is a corollary to the previous FAQ.
\par Long answer: In C++, member fns have an implicit parameter which points to the object (the "this" ptr inside the member fn).  Normal C fns can be thought of as having a different calling convention from member fns, so the types of their ptrs (ptr-to-membe
r-fn vs ptr-to-fn) are different and incompatible.  C++ introduces a new type of ptr, called a ptr-to-member, which can be invoked only by providing an object (see ARM 5.5).
\par {\b NOTE:}
 do NOT attempt to "cast" a ptr-to-mem-fn into a ptr-to-fn; the result is undefined and probably disastrous.  E.g., a ptr-to- member-fn is NOT required to contain the machine addr of the appropriate fn (see ARM, 8.1.2c, p.158).  As was said in the last ex
ample, if you have a ptr to a regular C fn, use either a top-level (non-member) fn, or a "static" (class) member fn.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} How_do_I_declare_an_array_of_pointers_to_member_functions_}${\footnote\ftnalt \pard\plain \s45 
\f8\fs20 {\cs47\super $} How do I declare an array of pointers to member functions?}}How do I declare an array of pointers to member functions?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Keep your sanity with "typedef".
\par      class Fred \{
\par      public:
\par        int f(char x, float y);
\par        int g(char x, float y);
\par        int h(char x, float y);
\par        int i(char x, float y);
\par        //...
\par      \};
\par 
\par      typedef  int (Fred::*FredPtr)(char x, float y);
\par 
\par Here's the array of pointers to member functions:
\par 
\par      FredPtr a[4] = \{ &Fred::f, &Fred::g, &Fred::h, &Fred::i \};
\par 
\par To call one of the member functions on object "fred":
\par 
\par      void userCode(Fred& fred, int methodNum, char x, float y)
\par      \{
\par        //assume "methodNum" is between 0 and 3 inclusive
\par        (fred.*a[methodNum])(x, y);
\par      \}
\par 
\par You can make the call somewhat clearer using a #define:
\par      #define  callMethod(object,ptrToMethod)  
\par ((object).*(ptrToMethod))
\par      callMethod(fred, a[methodNum]) (x, y);
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} How_can_I_insert_access_change_elements_from_a_linked_list_hashtable_etc_}${\footnote\ftnalt 
\pard\plain \s45 \f8\fs20 {\cs47\super $} How can I insert/access/change elements from a linked list/hashtable/etc?}}How can I insert/access/change elements from a linked list/hashtable/etc?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 
I'll use an "inserting into a linked list" as a prototypical example.  It's easy to allow insertion at the head and tail of the list, but limiting ourselves to these would produce a library that is too weak (a weak library is almost worse than no library)
.
\par This answer will be a lot to swallow for novice C++'ers, so I'll give a couple of options.  The first option is easiest; the second and third are better.
\par [1] Empower the "List" with a "current location," and methods such as advance(), backup(), atEnd(), atBegin(), getCurrElem(), setCurrElem(Elem), insertElem(Elem), and removeElem().  Although this works in small examples, the notion of "a" current position
 makes it difficult to access elements at two or more positions within the List (e.g., "for all pairs x,y do the following...").
\par [2
] Remove the above methods from the List itself, and move them to a separate class, "ListPosition."  ListPosition would act as a "current position" within a List.  This allows multiple positions within the same List.  ListPosition would be a friend of Lis
t, so List can hide its innards from the outside world (else the innards of List would have to be publicized via public methods in List). Note: ListPosition can use operator overloading for things like advance() and backup(), since operator overloading is
 syntactic sugar for normal methods.
\par [3] Consider the entire iteration as an atomic event, and create a class template to embodies this event.  This enhances performance by allowing the public access methods (which may be virtual fns) to be avoided during the inner loop.  Unfortunately you g
et extra object code in the application, since templates gain speed by duplicating code.  For more, see [Koenig, "Templates as interfaces," JOOP, 4, 5 (Sept 91)], and [Stroustrup, "The C++ Programming Language Second Edition," under "Comparator"].
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_s_the_idea_behind__templates__}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super $}
 What's the idea behind \ldblquote templates'?}}What's the idea behind "templates"?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 
A template is a cookie-cutter that specifies how to cut cookies that all look pretty much the same (although the cookies can be made of various kinds of dough, they'll all have the same basic shape).  In the same way, a class template is a cookie cutter t
o description of how to build a family of classes that all look basically the same, and a function template describes how to build a family of similar looking functions.
\par Class templates are often used to build type safe containers (although this only scratches the surface for how they can be used).
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_s_the_syntax___semantics_for_a__function_template__}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {
\cs47\super $} What's the syntax / semantics for a \ldblquote function template'?}}What's the syntax / semantics for a "function template"?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Consider this function that swaps its two integer arguments:
\par      void swap(int& x, int& y)
\par      \{
\par        int tmp = x;
\par        x = y;
\par        y = tmp;
\par      \}
\par 
\par If we also had to swap floats, longs, Strings, Sets, and FileSystems, we'd get pretty tired of coding lines that look almost identical except for the type. Mindless repetition is an ideal job for a computer, hence a function template:
\par 
\par      template<class T>
\par      void swap(T& x, T& y)
\par      \{
\par        T tmp = x;
\par        x = y;
\par        y = tmp;
\par      \}
\par Every time we used "swap()" with a given pair of types, the compiler will go to the above definition and will create yet another "template function" as an instantiation of the above.  E.g.,
\par      main()
\par      \{
\par        int    i,j;  /*...*/  swap(i,j);  //instantiates a swap for "int"
\par        float  a,b;  /*...*/  swap(a,b);  //instantiates a swap for "float"
\par        char   c,d;  /*...*/  swap(c,d);  //instantiates a swap for "char"
\par        String s,t;  /*...*/  swap(s,t);  //instantiates a swap for "String"
\par      \}
\par (note: a "template function" is the instantiation of a "function template").
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_s_the_syntax___semantics_for_a__class_template__}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {
\cs47\super $} What's the syntax / semantics for a \ldblquote class template'?}}What's the syntax / semantics for a "class template"?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Consider a container class of that acts like an array of integers:
\par      //this would go into a header file such as "Array.h"
\par      class Array \{
\par      public:
\par        Array(int len=10)                  : len_(len), data_(new int[len])\{\}
\par       ~Array()                            \{ delete [] data_; \}
\par        int len() const                    \{ return len_;     \}
\par        const int& operator[](int i) const \{ data_[check(i)]; \}
\par              int& operator[](int i)       \{ data_[check(i)]; \}
\par        Array(const Array&);
\par        Array& operator= (const Array&);
\par      private:
\par        int  len_;
\par        int* data_;
\par        int  check(int i) const
\par          \{ if (i < 0 || i >= len_) throw BoundsViol("Array", i, len_);
\par            return i; \}
\par      \};
\par 
\par Just as with "swap()" above, repeating the above over and over for Array of float, of char, of String, of Array-of-String, etc, will become tedious.
\par 
\par      //this would go into a header file such as "Array.h"
\par      template<class T>
\par      class Array \{
\par      public:
\par        Array(int len=10)                : len_(len), data_(new T[len]) \{ \}
\par       ~Array()                          \{ delete [] data_; \}
\par        int len() const                  \{ return len_;     \}
\par        const T& operator[](int i) const \{ data_[check(i)]; \}
\par              T& operator[](int i)       \{ data_[check(i)]; \}
\par        Array(const Array<T>&);
\par        Array& operator= (const Array<T>&);
\par      private:
\par        int len_;
\par        T*  data_;
\par        int check(int i) const
\par          \{ if (i < 0 || i >= len_) throw BoundsViol("Array", i, len_);
\par            return i; \}
\par      \};
\par Unlike template functions, template classes (instantiations of class templates) need to be explicit about the parameters over which they are instantiating:
\par 
\par      main()
\par      \{
\par        Array<int>           ai;
\par        Array<float>         af;
\par        Array<char*>         ac;
\par        Array<String>        as;
\par        Array< Array<int> >  aai;
\par      \}              // ^^^-- note the space; do NOT use
\par "Array<Array<int>>"
\par                     //       (the compiler sees ">>" as a single token).
\par 
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_is_a__parameterized_type__}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super $} What is a 
\ldblquote parameterized type'?}}What is a "parameterized type"?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Another way to say, "class templates."
\par A parameterized type is a type that is parameterized over another type or some value.  List<int> is a type ("List") parameterized over another type ("int")..{\f10\fs24 
\par }\pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_is__genericity__}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super $} What is \ldblquote 
genericity'?}}What is "genericity"?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Yet another way to say, "class templates."
\par Not to be confused with "generality" (which just means avoiding solutions which are overly specific), "genericity" means class templates.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} How_can_I_fake_templates_if_I_don_t_have_a_compiler_that_supports_them_}${\footnote\ftnalt \pard\plain 
\s45 \f8\fs20 {\cs47\super $} How can I fake templates if I don't have a compiler that supports them?}}How can I fake templates if I don't have a compiler that supports them?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 
The best answer is: buy a compiler that supports templates.  When this is not feasible, the next best answer is to buy or build a template preprocessor (ex: reads C++-with-templates, outputs C++-with-expanded-template-classes; such a system needn't be per
fect; it cost my company about three man-weeks to develop such a preprocessor).  If neither of these is feasible, you can use the macro preprocessor to fake templates.  But beware: it's
 tedious; templates are a better solution wrt development and maintenance costs.
\par Here's how you'd declare my "Vec" example from above.  First we define "Vec(T)" to concatenate the name "Vec" with that of the type T (ex: Vec(String) becomes "VecString").  This would go into a header file such as Vec.h:
\par \tab {\f11 #include <generic.h>\tab //to get the "name2()" macro
\par \tab #define  Vec(T)  name2(Vec,T)}{\f10\fs24 
\par }Next we declare the class Vec(T) using the name "Vecdeclare(T)" (in general you would postfix the name of the class with "declare", such as "Listdeclare" etc):{\f10\fs24 
\par }\tab {\f11 #define Vecdeclare(T)\tab \tab \tab \tab \tab \tab \\
\par \tab class Vec(T) \{\tab \tab \tab \tab \tab \tab \tab \\
\par \tab   int  xlen;\tab \tab \tab \tab \tab \tab \tab \\
\par \tab   T*   xdata;\tab \tab \tab \tab \tab \tab \tab \\
\par \tab   int  check(int i);  /*return i if in bounds else throw*/\tab \\
\par \tab public:\tab \tab \tab \tab \tab \tab \tab \tab \\
\par \tab   int       len()             const \{ return xlen;     \}\tab \\
\par \tab   const T&  operator[](int i) const \{ xdata[check(i)]; \}\tab \\
\par \tab         T&  operator[](int i)       \{ xdata[check(i)]; \}\tab \\
\par \tab             Vec(T)(int L=10): xlen(L), xdata(new T[L]) \{/*...*/\}\\
\par \tab            ~Vec(T)()                   \{ delete [] xdata; \}\tab \\
\par \tab \};
\par }Note how each occurrence of "Vec" has the "(T)" postfixed.  Finally we set up another macro that "implements" the non-inline member function(s) of Vec:{\f10\fs24 
\par }\tab {\f11 //strangely enough this can also go into Vec.h
\par \tab #define Vecimplement(T)\tab \tab \tab \tab \tab \tab \\
\par \tab int Vec(T)::check(int i)\tab \tab \tab \tab \tab \\
\par \tab \{\tab \tab \tab \tab \tab \tab \tab \tab \\
\par \tab   if (i < 0 || i >= xlen) throw BoundsViol("Vec", i, xlen);\tab \\
\par \tab   return i;\tab \tab \tab \tab \tab \tab \tab \\
\par \tab \}}{\f10\fs24 
\par }When you which to use a Vec-of-String and Vec-of-int, you would say:{\f10\fs24 
\par }\tab {\f11 #include "Vec.h"     //pulls in <generic.h> too; see below...
\par \tab declare(Vec,String)  //"declare()" is a macro defined in <generic.h>
\par \tab declare(Vec,int)
\par \tab Vec(String) vs;      //Vec(String) becomes the single token "VecString"
\par \tab Vec(int)    vi;}{\f10\fs24 
\par }In exactly one source file in the system, you must provide implementations for the non-inlined member functions:
\par \tab {\f11 #include "Vec.h"
\par \tab declare  (Vec,String)   declare  (Vec,int)   declare  (Vec,float)
\par \tab implement(Vec,String)   implement(Vec,int)   implement(Vec,float)}{\f10\fs24 
\par }Note that types whose names are other than a single identifier do not work properly.  Ex: Vec(char*) creates a class whose name is "Vecchar*".  The patch is to create a typedef for the appropriate type:
\par \tab {\f11 #include "Vec.h"
\par \tab typedef char* charP;
\par \tab declare(Vec,charP)}{\f10\fs24 
\par }
It is important that every declaration of what amounts to "Vec<char*>" must all use exactly the same typedef, otherwise you will end up with several equivalent classes, and you"ll have unnecessary code duplication.  This is the sort of tedium which a temp
late mechanism can handle for you.{\f10\fs24 
\par }\pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} Why_are_classes_with_static_data_members_getting_linker_errors_}${\footnote\ftnalt \pard\plain \s45 
\f8\fs20 {\cs47\super $} Why are classes with static data members getting linker errors?}}Why are classes with static data members getting linker errors?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Static data members must be explicitly defined in exactly one module. 
\par E.g.,
\par      class Fred \{
\par      public:
\par        //...
\par      private:
\par        static int i_;  //declares static data member "Fred::i_"
\par        //...
\par      \};
\par The linker will holler at you ("Fred::i_ is not defined") unless you define (as opposed to declare) "Fred::i_" in (exactly) one of your source files:
\par      int Fred::i_ = some_expression_evaluating_to_an_int; or:
\par      int Fred::i_;
\par The usual place to define static data members of class "Fred" is file "Fred.C" (or "Fred.cpp", etc; whatever filename extension you use).
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_s_the_difference_between_the_keywords_struct_and_class_}${\footnote\ftnalt \pard\plain \s45 
\f8\fs20 {\cs47\super $} What's the difference between the keywords struct and class?}}What's the difference between the keywords struct and class?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 
The members and base classes of a struct are public by default, while in class, they default to private.  Note: you should make your base classes EXPLICITLY public, private, or protected, rather than relying on the defaults.
\par "struct" and "class" are otherwise functionally equivalent.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} Why_can_t_I_overload_a_function_by_its_return_type_}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {
\cs47\super $} Why can't I overload a function by its return type?}}Why can't I overload a function by its return type?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 If you declare both "char f()" and "float f()", the compiler gives you an error message, since calling simply "f()" would be ambiguous.{\f10\fs24 
\par }\pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 {\f10 \page }{\cs47\super #{\footnote\ftnalt \pard\plain \s45 \f8\fs20 {\cs47\super #} What_is__persistence____What_is_a__persistent_object__}${\footnote\ftnalt \pard\plain \s45 \f8\fs20 {
\cs47\super $} What is \ldblquote persistence'?  What is a \ldblquote persistent object'?}}What is "persistence"?  What is a "persistent object"?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 
A persistent object can live after the program which created it has stopped. Persistent objects can even outlive different versions of the creating program, can outlive the disk system, the operating system, or even the hardware on which the OS was runnin
g when they were created.
\par The challenge with persistent objects is to effectively store their method code out on secondary storage along with their data bits (and the data bits and method code of all member objects, and of all their member objects and base classes, etc).  This is 
non-trivial when you have to do it yourself.  In C++, you have to do it yourself.  C++/OO databases can help hide the mechanism for all this.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 \page {\cs46\super #{\footnote \pard\plain \s17\li144\ri144\sl240\slmult0 \f5\fs20 {\cs46\super #} Which_newsgroup_should_I_post_my_questions_}${\footnote \pard\plain 
\s17\li144\ri144\sl240\slmult0 \f5\fs20 {\cs46\super $} Which newsgroup should I post my questions?}}Which newsgroup should I post my questions?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 
Comp.lang.c++ is the best place to discuss the C++ language itself (e.g., C++ code design, syntax, style). Other newsgroups exist for discussion of topics which are specific to a particular system (e.g., MS indows or UNIX) or topics which are not directly
 related to the C++ language (e.g., how to use your compiler). Here's a list of some very active newsgroups and excerpts from their Frequently Asked Questions lists. 
\par These excerpts should give you an idea of the type of topics frequently discussed there.
\par \pard\plain \s21\fi-216\li360\ri144\sb140\sl240\slmult0 \b\f5\fs20 comp.os.ms-windows.programmer.tools
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 This group is intended for discussions about the selection and use of tools for Windows software development.
\par \pard\plain \s21\fi-216\li360\ri144\sb140\sl240\slmult0 \b\f5\fs20 comp.os.ms-windows.programmer.misc
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 This group is for all other discussions about Windows software development.
\par [There's one FAQ list for all the comp.os.ms-windows.programmer.* groups]
\par \pard\plain \s23\fi-187\li360\ri144\sa60\sl240\slmult0\tx360 \f5\fs20 \{bmc bullet.mrb\}\tab FAQ 5.7.1. Accessing C++ classes in a DLL
\par \{bmc bullet.mrb\}\tab FAQ 6.1.1. A dialog as an MDI child window [with OWL]
\par \{bmc bullet.mrb\}\tab FAQ 6.2.1. Disabled menu choices become enabled [with MFC]
\par \{bmc bullet.mrb\}\tab FAQ 8.1.5. Using STRICT with windows.h
\par \{bmc bullet.mrb\}\tab FAQ 10. A programmer's bibliography
\par \pard\plain \s21\fi-216\li360\ri144\sb140\sl240\slmult0 \b\f5\fs20 comp.os.msdos.programmer
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Much of the traffic is about language products (chiefly from Borland and Microsoft).
\par \pard\plain \s23\fi-187\li360\ri144\sa60\sl240\slmult0\tx360 \f5\fs20 \{bmc bullet.mrb\}\tab FAQ 301. How can I read a character without [waiting for] the Enter key?
\par \{bmc bullet.mrb\}\tab FAQ 412. How can I read, create, change, or delete the volume label?
\par \{bmc bullet.mrb\}\tab FAQ 504. How do I configure a COM port and use it to transmit data?
\par \{bmc bullet.mrb\}\tab FAQ 602. How can a C program send control codes to my printer?
\par \{bmc bullet.mrb\}\tab FAQ 606. How can I find the Microsoft mouse position and button status?
\par \{bmc bullet.mrb\}\tab FAQ 707. How can I write a TSR (terminate-stay-resident) utility?
\par \{bmc bullet.mrb\}\tab FAQ B0. How can I contact [Borland, Microsoft]?
\par \pard\plain \s36\fi-576\li720\ri144\sb40\sa60\sl240\slmult0\tx720\tx8820 \f5\fs20 {\b Note: }
this FAQ is not available at rtfm.mit.edu; it is at Simtel (e.g., oak.oakland.edu) in /pub/msdos/info/faqp*.zip and Garbo (garbo.uwasa.fi) in /pc/doc-net/faqp*.zip]
\par \pard\plain \s21\fi-216\li360\ri144\sb140\sl240\slmult0 \b\f5\fs20 comp.os.msdos.programmer.turbovision {\b0 [Borland's character-mode framework]
\par }comp.unix.programmer
\par \pard\plain \s23\fi-187\li360\ri144\sa60\sl240\slmult0\tx360 \f5\fs20 \{bmc bullet.mrb\}\tab FAQ 4.5:  How do I use popen() to open a process for reading AND writing?
\par \{bmc bullet.mrb\}\tab FAQ 4.6:  How do I sleep() in a C program for less than one second?
\par \pard\plain \s21\fi-216\li360\ri144\sb140\sl240\slmult0 \b\f5\fs20 comp.unix.solaris (covers SunOS 4.x and Solaris)
\par \pard\plain \s23\fi-187\li360\ri144\sa60\sl240\slmult0\tx360 \f5\fs20 \{bmc bullet.mrb\}\tab FAQ 4:  Signal Primer
\par \{bmc bullet.mrb\}\tab FAQ 5:  Waiting for Children to Exit
\par \pard\plain \s21\fi-216\li360\ri144\sb140\sl240\slmult0 \b\f5\fs20 gnu.g++.help
\par \pard\plain \s23\fi-187\li360\ri144\sa60\sl240\slmult0\tx360 \f5\fs20 \{bmc bullet.mrb\}\tab FAQ: Where can I find a demangler?
\par \{bmc bullet.mrb\}\tab FAQ: Getting gcc/g++ binaries for Solaris 2.x
\par \{bmc bullet.mrb\}\tab FAQ: What documentation exists for g++ 2.x?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 gnu.g++.bug [bug reports for g++ -- see the g++ docs]
\par \pard\plain \s21\fi-216\li360\ri144\sb140\sl240\slmult0 \b\f5\fs20 comp.lang.c
\par \pard\plain \s23\fi-187\li360\ri144\sa60\sl240\slmult0\tx360 \f5\fs20 \{bmc bullet.mrb\}\tab FAQ 1.10: I'm confused. NULL is guaranteed to be 0, but the null pointer is not?
\par \{bmc bullet.mrb\}\tab FAQ 2.3:  So what is meant by the "equivalence of pointers and arrays" in C?
\par \{bmc bullet.mrb\}\tab FAQ 4.2:  [Why doesn't "printf("%d\\n," i++ * i++);" work?]
\par \{bmc bullet.mrb\}\tab FAQ 7.1:  How can I write a function that takes a variable number of arguments? [stdarg.h or varargs.h]
\par \{bmc bullet.mrb\}\tab FAQ 10.4: How do I declare an array of pointers to functions returning pointers to functions returning pointers to characters?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Also check out the newsgroups comp.graphics, comp.sources.wanted, comp.programming, and comp.object (its FAQ is an excellent introduction and overview of OOP terms and concepts). 
\par Remember that comp.std.c++ is for discussion DIRECTLY related to the evolving ANSI/ISO C++ Standard (see more below). 
\par There's rarely a need to crosspost a question to one of the above newsgroups and comp.lang.c++ (readers in the system-specific newsgroups aren't programming in machine language, ya know). It's bad netiquette to crosspost widely because your problem is "re
ally important."  If you don't get an answer in the "right" newsgroup and feel you must post here, at least consider redirecting followups back to the appropriate newsgroup.
\par Before posting a question to any newsgroup you should read it's FAQ list. An answer to your question is likely to be there, saving you the time of posting and saving thousands of other people around the world the time of reading your question. People answ
ering a FAQ are likely to be annoyed for having to answer it for the umpteenth time, or they're likely to be giving you a wrong or incomplete answer since they haven't read the FAQ either.
\par Frequently Asked Questions lists are available 24-hours a day via anonymous ftp (rtfm.mit.edu in /pub/usenet/comp.what.ever) or e-mail server (send a message with the line "help" to mail-server@rtfm.mit.edu). See the article "Introduction to the *.answers
 newsgroups" in the newsgroup news.answers or news.announce.newusers (which contains many other must-read articles) for more information.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 \page {\cs46\super #{\footnote \pard\plain \s17\li144\ri144\sl240\slmult0 \f5\fs20 {\cs46\super #} How_do_I_post_a_question_about_code_that_doesn_t_work_correctly_}${\footnote \pard\plain 
\s17\li144\ri144\sl240\slmult0 \f5\fs20 {\cs46\super $} How do I post a question about code that doesn't work correctly?}}How do I post a question about code that doesn't work correctly?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Here's some guidelines you should follow that will help people reading comp.lang.c++ help you with an answer to your programming problem.
\par \pard\plain \s30\fi-216\li360\ri144\sa60\sl240\slmult0\tx360 \f5\fs20 1.\tab 
Please read the previous FAQ to make sure that your question is about the C++ language and not a question about programming on your system (e.g., graphics, printers, devices, etc.) or using your compilation environment (e.g., "the IDE
 crashes when I...," "how do you turn off warnings about...," "how do I tell it to link my libraries"). If you want to know why your virtual CmOk() function isn't being called in your OWL program, your question is probably more appropriate in the Windows 
programming newsgroup. If you can write a small stand-alone program which exhibits the same undesired compiler error or behavior as your OWL program, by all means post here in comp.lang.c++ since C++ programmers using other systems could be of help.

\par 2.\tab Be d
escriptive in the subject line. "C++ problem" leaves a lot to the imagination. "Problem new'ing a multi-dimensional array" is good. Refrain from exclamation points, cries for HELPPP, and the once funny "SEX SEX SEX."  If you think the problem is specific 
to your compiler, you might want to mention the compiler/version in the subject line.
\par 3.\tab Post code that is complete and compilable. It's extremely difficult to debug or reconstruct a program from a human language description. By "complete code" I mean that 
any types and functions used are declared, headers are #include'd, etc. Please strip the code down to the bare essentials. We don't need a program that does something useful at run-time, or even links. We just need to be able to reproduce the undesired co
mpiler error (possibly on a different compiler). By "compilable code" I mean that it doesn't contain a bunch of uncommented ellipses or line numbers at the beginning of each line:
\par \pard\plain \s19\fi-216\li360\ri144\sl240\slmult0\tx360 \f11\fs20 \tab 14:  #include <iostream.h>
\par \tab 15:  class Foo \{ ... \};  // this is annoying
\par \pard\plain \s20\li360\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Try
 to organize the code into one linear program instead of making us cut out and create header files. Be very careful if you are typing the code into your article -- it's often difficult to tell whether something is a typo or the real cause of the problem. 
Try using your editor's cut&paste or "insert file" feature instead.
\par \pard\plain \s30\fi-216\li360\ri144\sa60\sl240\slmult0\tx360 \f5\fs20 4.\tab 
Mention what compiler, compiler version, and system you're using. I know, I just said that system-specific questions should go to a system-specific newsgroup, but compiler information is
 often very useful in diagnosing the problem: ("yeah, I remember Acme 1.2 having lots of problems in this area"). It also warns other users of that compiler about possible bugs.
\par 5.\tab Show us the exact compiler and linker options and libraries you used when building your program.
\par 6.\tab List the exact error message and where the error was given. "Virtual functions don't work" doesn't tell us whether its a compile-, link-, or run-time problem. If the problem is at run-time, give a good description of the behavior a
nd any relevant information about your system setup.
\par 7.\tab 
Include a working e-mail address in your signature. If the address in given your article's "From:" line is not correct, please notify your system administrator. Until it is fixed, add a "Reply-To:" line to your headers that uses your correct e-mail add
ress.
\par 8.\tab Please read the rest of this FAQ -- chances are your problem, or a closely related problem, is discussed here. Thank you and I hope these suggestions help you find a solution to your problem.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 \page {\cs46\super #{\footnote \pard\plain \s17\li144\ri144\sl240\slmult0 \f5\fs20 {\cs46\super #} How_should_I_handle_resources_if_my_constructors_may_throw_exceptions_}${\footnote 
\pard\plain \s17\li144\ri144\sl240\slmult0 \f5\fs20 {\cs46\super $} How should I handle resources if my constructors may throw exceptions?}}How should I handle resources if my constructors may throw exceptions?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Every data member inside your object should clean up its own mess.
\par If a constructor throws an exception, the object's destructor is NOT run. If your object has already done something that needs to be undone (such as allocating some memory, opening a file, or locking a semaphore), this "stuff th
at needs to be undone" MUST be remembered by a data member inside the object.
\par For example, rather than allocating memory into a raw "Fred*" data member, put the allocated memory into a "smart pointer" member object, and the destructor of this smart pointer will delete the Fred object when the smart pointer dies.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 \page {\cs46\super #{\footnote \pard\plain \s17\li144\ri144\sl240\slmult0 \f5\fs20 {\cs46\super #}
 What_do_I_do_if_I_want_to_update_an__invisible__data_member_inside_a__const__member_function_}${\footnote \pard\plain \s17\li144\ri144\sl240\slmult0 \f5\fs20 {\cs46\super $}
 What do I do if I want to update an "invisible" data member inside a "const" member function?}}What do I do if I want to update an "invisible" data member inside a "const" member function?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Use "mutable", or use "const_cast".
\par A small percentage of inspectors need to make innocuous changes to data members
\par (e.g., a "Set" object might want to cache its last lookup in hopes of improving the performance of its next lookup). By saying the changes are "inocuous," I mean that the changes wouldn't be visible from outside the object's interface (otherwise the metho
d would be a mutator rather than an inspector).
\par When this happens, the data member which will be modified should be marked as "mutable" (put the "mutable" keyword just before the data member's declaration; i.e., in the same place where you could put "const"). This tells the compiler that the data membe
r is allowed to change during a const member function. If you can't use "mutable", you can cast away the constness of "this" via "const_cast". E.g., in "Set::lookup() const", you might say,
\par \pard\plain \s19\fi-216\li360\ri144\sl240\slmult0\tx360 \f11\fs20 Set* self = const_cast<Set*>(this);
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 After this line, "self" will h
ave the same bits as "this" (e.g., "self==this"), but "self" is a "Set*" rather than a "const Set*". Therefore you can use "self" to modify the object pointed to by "this".
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 \page {\cs46\super #{\footnote \pard\plain \s17\li144\ri144\sl240\slmult0 \f5\fs20 {\cs46\super #} Does__const_cast__mean_lost_optimization_opportunities_}${\footnote \pard\plain 
\s17\li144\ri144\sl240\slmult0 \f5\fs20 {\cs46\super $} Does "const_cast" mean lost optimization opportunities?}}Does "const_cast" mean lost optimization opportunities?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 In theory, yes; in practice, no.
\par Even if a compiler outlawed "const_cast", the only way to avoid flushing the register cache across a "const" member function call w
ould be to ensure that there are no non-const pointers that alias the object. This can happen only in rare cases (when the object is constructed in the scope of the const member fn invocation, and when all the non-const member function invocations between
 the object's construction and the const member fn invocation are statically bound, and when every one of these invocations is also "inline"d, and when the constructor itself is "inline"d, and when any member fns the constructor calls are inline).
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 \page {\cs46\super #{\footnote \pard\plain \s17\li144\ri144\sl240\slmult0 \f5\fs20 {\cs46\super #} How_do_you_use_inheritance_in_C____and_is_that_different_from_Smalltalk_}${\footnote 
\pard\plain \s17\li144\ri144\sl240\slmult0 \f5\fs20 {\cs46\super $} How do you use inheritance in C++, and is that different from Smalltalk?}}How do you use inheritance in C++, and is that different from Smalltalk?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Some people believe that the purpose of inheritance is code reuse. In C++, this is wrong. Stated plainly, "inheritance is not 'for' code reuse."
\par The purpose of inheritance in C++ is to express interface compliance (subtyping), not to get code reuse. In C++, code reuse usually comes via composit
ion rather than via inheritance. In other words, inheritance is mainly a specification technique rather than an implementation technique.
\par This is a major difference with Smalltalk, where there is only one form of inheritance (C++ provides "private" inheritance to mean "share the code but don't conform to the interface", and "public" inheritance to mean "kind-of"). The Smalltalk language pro
per (as opposed to coding practice) allows you to have the EFFECT of "hiding" an inherited method by providing an overr
ide that calls the "does not understand" method. Furthermore Smalltalk allows a conceptual "is-a" relationship to exist APART from the subclassing hierarchy (subtypes don't have to be subclasses; e.g., you can make something that is-a Stack yet doesn't in
herit from class Stack).
\par In contrast, C++ is more restrictive about inheritance: there's no way to make a "conceptual is-a" relationship without using inheritance (the C++ work-around is to separate interface from implementation via ABCs). The C++ compiler 
exploits the added semantic information associated with public inheritance to provide static typing.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 \page {\cs46\super #{\footnote \pard\plain \s17\li144\ri144\sl240\slmult0 \f5\fs20 {\cs46\super #} What_are_the_practical_consequences_of_the_differences_in_Smalltalk_C___inheritance_}$
{\footnote \pard\plain \s17\li144\ri144\sl240\slmult0 \f5\fs20 {\cs46\super $} What are the practical consequences of the differences in Smalltalk/C++ inheritance?}}What are the practical consequences of the differences in Smalltalk/C++ inheritance?

\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 Smalltalk lets you make a subtype that isn't a subclass, and allows you to make a subclass that isn't a subtype. This allows Smalltalk programmers to
 be very carefree in putting data (bits, representation, data structure) into a class (e.g., you might put a linked list into a Stack class). After all, if someone wants an array-based-Stack, they don't have to inherit from Stack; they could inherit such 
a class from Array if desired, even though an ArrayBasedStack is NOT a kind-of Array!
\par In C++, you can't be nearly as carefree. Only mechanism (method code), but not representation (data bits) can be overridden in subclasses. Therefore you're usually better 
off NOT putting the data structure in a class. This leads to a stronger reliance on Abstract Base Classes (ABCs).
\par I like to think of the difference between an ATV and a Maseratti. An ATV (all terrain vehicle) is more fun, since you can "play around" by driving through fields, streams, sidewalks, and the like. A Maseratti, on the other hand, gets you there faster, but
 it forces you to stay on the road. My advice to C++ programmers is simple: stay on the road. Even if you're one of those people who like the "expressive freedom" to drive through the bushes, don't do it in C++; it's not a good fit.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 \page {\cs46\super #{\footnote \pard\plain \s17\li144\ri144\sl240\slmult0 \f5\fs20 {\cs46\super #} Do_you_need_to_learn_a__pure__OOPL_before_you_learn_C___}${\footnote \pard\plain 
\s17\li144\ri144\sl240\slmult0 \f5\fs20 {\cs46\super $} Do you need to learn a "pure" OOPL before you learn C++?}}Do you need to learn a "pure" OOPL before you learn C++?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 No (in fact, doing so might actually hurt you).
\par (Note that Smalltalk is a "pure" OOPL, and C++ is a "hybrid" OOPL). Before reading this, please read the previous FAQs on the difference between C++ and Smalltalk.
\par The "purity" of the OOPL doesn't
 make the transition to C++ any easier. In fact, the typical use of dynamic typing and non-subtyping inheritance can make it even harder for Smalltalk programmers to learn C++. Paradigm Shift, Inc., has taught OO technology to literally thousands of peopl
e, and we have noticed that people who want to learn C++ from a Smalltalk background usually have just as hard a time as those who've never seen inheritance before. In fact, those with extensive experience with a dynamically typed OOPL (usually but not al
ways Smalltalk) might even have a HARDER time, since it's harder to UNLEARN habits than it is to learn the statically typed way from the beginning.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 \page {\cs46\super #{\footnote \pard\plain \s17\li144\ri144\sl240\slmult0 \f5\fs20 {\cs46\super #} What_is_the_NIHCL___Where_can_I_get_it_}${\footnote \pard\plain 
\s17\li144\ri144\sl240\slmult0 \f5\fs20 {\cs46\super $} What is the NIHCL?  Where can I get it?}}What is the NIHCL?  Where can I get it?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 NIHCL stands for "national-institute-of-health's-class-library." it can be acquired via anonymous ftp from [128.231.128.7] in the file pub/nihcl-3.0.tar.Z
\par NIHCL (some people pronounce it "N-I-H-C-L," others pronounce it like "nickel") is a
 C++ translation of the Smalltalk class library. There are some ways where NIHCL's use of dynamic typing helps (e.g., persistent objects). There are also places where its use of dynamic typing creates tension with the static typing of the C++ language.

\par See previous FAQs on Smalltalk for more.
\par \pard\plain \s39\li144\ri144\sa104\sl240\slmult0\keepn \b\f5\cf2 \page {\cs46\super #{\footnote \pard\plain \s17\li144\ri144\sl240\slmult0 \f5\fs20 {\cs46\super #} Where_can_I_get_a_copy_of__STL__}${\footnote \pard\plain \s17\li144\ri144\sl240\slmult0 
\f5\fs20 {\cs46\super $} Where can I get a copy of "STL"?}}Where can I get a copy of "STL"?
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 "STL" is the "Standard Templates Library". You can get a copy from:
\par \pard\plain \s25\fi-2563\li2707\ri144\sb40\sa60\sl240\slmult0\tx2700 \f5\fs20 STL HP official site:\tab ftp://butler.hpl.hp.com/stl
\par STL code alternate:\tab ftp://ftp.cs.rpi.edu/stl
\par STL code + examples:\tab http://www.cs.rpi.edu/~musser/stl.html
\par hacks for GCC-2.6.3:\tab ftp://ftp.uni-bremen.de/pub/.mount/ruin/C++/STL
\par \pard\plain \li144\ri144\sb40\sa60\sl240\slmult0 \f5\fs20 
\par \pard\plain \s43 \f5 {\f11\fs20 
\par }{\f10 
\par }}